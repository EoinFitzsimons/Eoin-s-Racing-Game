<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Racing Game</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", "Roboto", "Helvetica Neue", sans-serif;
        background: linear-gradient(
          135deg,
          var(--bg-primary, #0f0f23),
          var(--bg-secondary, #1a1a3a)
        );
        color: white;
        overflow: hidden;
      }

      :root {
        /* Default theme*/
        --primary-color: #1e41ff;
        --accent-color: #ff1801;
        --bg-primary: #0a0e2e;
        --bg-secondary: #1a1d3a;
        --text-primary: #ffffff;
        --text-secondary: #b8c5ff;
        --border-glow: rgba(30, 65, 255, 0.4);
      }

      .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        position: relative;
      }

      #gameCanvas {
        border: 3px solid var(--primary-color);
        border-radius: 12px;
        box-shadow: 0 0 30px var(--border-glow);
        background: linear-gradient(45deg, #1a1a1a, #0d0d0d);
      }

      /* Team Selection Screen */
      .team-selection-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          135deg,
          var(--bg-primary),
          var(--bg-secondary)
        );
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
      }

      .team-selection-title {
        font-size: 3.5rem;
        font-weight: 700;
        color: var(--primary-color);
        text-shadow: 0 0 20px var(--border-glow);
        margin-bottom: 1rem;
        letter-spacing: 2px;
      }

      .team-selection-subtitle {
        font-size: 1.4rem;
        color: var(--text-secondary);
        margin-bottom: 3rem;
        font-weight: 300;
      }

      .teams-grid {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 3rem;
        max-width: 1200px;
        width: 100%;
        position: relative;
        perspective: 1000px;
      }

      .team-carousel-container {
        position: relative;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .team-carousel {
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        width: 100%;
        height: 520px;
        max-width: 80%;
      }

      .team-card {
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.05),
          rgba(255, 255, 255, 0.02)
        );
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 1.2rem 1rem;
        cursor: pointer;
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);

        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        width: 350px;
        height: 480px;
        text-align: center;
        position: absolute;
        overflow: hidden;
        transform-style: preserve-3d;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .team-card.active {
        transform: translateX(0) scale(1);
        opacity: 1;
        z-index: 3;
        border-color: var(--primary-color);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3),
          0 0 0 2px var(--primary-color);
      }

      .team-card.prev {
        transform: translateX(-200px) scale(0.8);
        opacity: 0.4;
        z-index: 1;
      }

      .team-card.next {
        transform: translateX(200px) scale(0.8);
        opacity: 0.4;
        z-index: 1;
      }

      .team-card.hidden {
        transform: translateX(0) scale(0.5);
        opacity: 0;
        z-index: 0;
        pointer-events: none;
      }

      .team-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(
          90deg,
          var(--primary-color),
          var(--accent-color)
        );
        opacity: 0;
        transition: opacity 0.3s;
      }

      .team-card:hover {
        transform: translateY(-8px);
        border-color: var(--primary-color);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3),
          0 0 0 1px var(--primary-color);
      }

      .team-card:hover::before {
        opacity: 1;
      }

      .team-card.selected {
        border-color: var(--primary-color);
        background: linear-gradient(
          145deg,
          var(--border-glow),
          rgba(255, 255, 255, 0.05)
        );
        transform: translateY(-4px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      .team-card.selected::before {
        opacity: 1;
      }

      .team-logo {
        font-size: 2rem;
        font-weight: 900;
        font-family: "Arial Black", "Impact", sans-serif;
        margin-bottom: 0.5rem;
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--accent-color)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        color: transparent;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        letter-spacing: 1px;
        border: 2px solid var(--primary-color);
        border-radius: 8px;
        padding: 0.5rem;
        background-color: rgba(255, 255, 255, 0.05);
        -webkit-backdrop-filter: blur(5px);
        backdrop-filter: blur(5px);
        position: relative;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .car-livery {
        width: 100%;
        height: 60px;
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--accent-color)
        );
        border-radius: 8px;
        margin: 0.5rem 0;
        position: relative;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .car-livery::before {
        content: "";
        position: absolute;
        top: 20%;
        left: 10%;
        right: 10%;
        bottom: 20%;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.1) 0%,
          rgba(255, 255, 255, 0.3) 20%,
          rgba(255, 255, 255, 0.1) 40%,
          rgba(255, 255, 255, 0.3) 60%,
          rgba(255, 255, 255, 0.1) 100%
        );
        border-radius: 4px;
        animation: carShine 2s ease-in-out infinite;
      }

      @keyframes carShine {
        0%,
        100% {
          opacity: 0.7;
        }

        50% {
          opacity: 1;
        }
      }

      .team-facts {
        text-align: left;
        font-size: 0.8rem;
        line-height: 1.3;
        margin-top: 0.5rem;
        flex-grow: 1;
      }

      .team-facts .fact-row {
        display: flex;
        justify-content: space-between;
        margin: 0.3rem 0;
        padding: 0.15rem 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .team-facts .fact-label {
        color: var(--text-secondary);
        font-weight: 500;
      }

      .team-facts .fact-value {
        color: var(--text-primary);
        font-weight: 600;
      }

      .team-attributes {
        margin-top: 1rem;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .attributes-title {
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.8rem;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .attribute-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.6rem;
        font-size: 0.8rem;
      }

      .attribute-name {
        color: var(--text-secondary);
        font-weight: 400;
        flex: 1;
      }

      .attribute-bar {
        flex: 2;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        margin: 0 0.5rem;
        overflow: hidden;
      }

      .attribute-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff4444, #ffaa44, #44ff44);
        border-radius: 2px;
        transition: width 0.3s ease;
      }

      .attribute-value {
        color: var(--text-primary);
        font-weight: 600;
        min-width: 20px;
        text-align: right;
      }

      .carousel-nav {
        position: relative;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid var(--primary-color);
        color: var(--primary-color);
        cursor: pointer;
        transition: all 0.3s;
        z-index: 50;
        font-size: 1.8rem;
        width: 40px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        margin: 0 20px;
      }

      .carousel-nav:hover {
        background: var(--primary-color);
        color: var(--bg-primary);
        transform: scale(1.1);
      }

      .carousel-nav.prev {
        border-top-left-radius: 6px;
        border-bottom-left-radius: 6px;
      }

      .carousel-nav.next {
        border-top-right-radius: 6px;
        border-bottom-right-radius: 6px;
      }

      .team-name {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 0.3rem;
        color: var(--text-primary);
      }

      .team-description {
        font-size: 0.9rem;
        color: var(--text-secondary);
        font-weight: 300;
        line-height: 1.4;
      }

      .professional-btn {
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--accent-color)
        );
        color: white;
        border: none;
        padding: 1rem 2.5rem;
        font-size: 1.1rem;
        font-weight: 600;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        letter-spacing: 0.5px;
        text-transform: uppercase;
        position: relative;
        overflow: hidden;
        margin: 1rem auto;
        display: block;
        text-align: center;
        line-height: 1.2;
      }

      .professional-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .professional-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      }

      .professional-btn:hover::before {
        left: 100%;
      }

      .professional-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .ui-overlay,
      .controls-info,
      .position-display {
        display: none;
      }

      .game-running .ui-overlay,
      .game-running .controls-info,
      .game-running .position-display {
        display: block;
      }

      /* Leaderboard is handled separately in JS */

      .ui-overlay {
        position: absolute;
        top: 20px;
        left: 20px;
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.9),
          rgba(0, 0, 0, 0.8)
        );
        padding: 1.5rem;
        border-radius: 8px;
        border-left: 4px solid var(--primary-color);
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        font-size: 1rem;
        z-index: 10;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        font-family: "Arial", "Helvetica", sans-serif;
        font-weight: 500;
      }

      .ui-item {
        margin-bottom: 0.8rem;
        display: flex;
        justify-content: space-between;
        min-width: 180px;
        align-items: center;
        padding: 0.2rem 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .ui-item:last-child {
        border-bottom: none;
      }

      .ui-item span:first-child {
        color: var(--text-secondary);
        font-weight: 400;
        text-transform: uppercase;
        font-size: 0.85rem;
        letter-spacing: 0.5px;
      }

      .ui-item span:last-child {
        color: var(--text-primary);
        font-weight: 700;
        font-size: 0.95rem;
      }

      .controls-info {
        position: absolute;
        top: 20px;
        right: 20px;
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.9),
          rgba(0, 0, 0, 0.8)
        );
        padding: 1.5rem;
        border-radius: 8px;
        border-right: 4px solid var(--accent-color);
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        font-size: 0.9rem;
        z-index: 10;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        font-family: "Arial", "Helvetica", sans-serif;
        font-weight: 500;
      }

      .start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          135deg,
          var(--bg-primary),
          var(--bg-secondary)
        );
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
      }

      .title {
        font-size: 3.5rem;
        font-weight: 700;
        color: var(--primary-color);
        text-shadow: 0 0 20px var(--border-glow);
        margin-bottom: 1rem;
        letter-spacing: 2px;
      }

      .start-instructions {
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.05),
          rgba(255, 255, 255, 0.02)
        );
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 2rem;
        margin-top: 2rem;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        text-align: center;
      }

      .start-instructions h3 {
        color: var(--primary-color);
        margin-bottom: 1rem;
        font-size: 1.3rem;
      }

      .start-instructions p {
        margin: 0.5rem 0;
        color: var(--text-secondary);
        font-size: 1rem;
      }
      
      /* Difficulty selector styles */
      .difficulty-selector {
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.05),
          rgba(255, 255, 255, 0.02)
        );
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 1.5rem;
        margin-top: 1.5rem;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        text-align: center;
        width: 90%;
        max-width: 500px;
      }
      
      .difficulty-selector h3 {
        color: var(--primary-color);
        margin-bottom: 1rem;
        font-size: 1.3rem;
      }
      
      .difficulty-buttons {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1rem;
      }
      
      .difficulty-btn {
        flex: 1;
        padding: 0.6rem 0.5rem;
        margin: 0 0.5rem;
        background-color: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: bold;
      }
      
      .difficulty-btn:hover {
        background-color: rgba(255, 255, 255, 0.15);
        border-color: var(--primary-color);
      }
      
      .difficulty-btn.active {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
        box-shadow: 0 0 15px var(--border-glow);
      }
      
      .difficulty-description {
        color: var(--text-secondary);
        font-size: 0.9rem;
        margin-top: 0.5rem;
        min-height: 40px;
      }

      /* Weather selector styles - matches difficulty selector */
      .weather-selector {
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.05),
          rgba(255, 255, 255, 0.02)
        );
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 1.5rem;
        margin-top: 1.5rem;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        text-align: center;
        width: 90%;
        max-width: 500px;
      }

      .weather-selector h3 {
        color: var(--primary-color);
        margin-bottom: 1rem;
        font-size: 1.3rem;
      }

      .weather-buttons {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1rem;
      }

      .weather-btn {
        flex: 1;
        padding: 0.6rem 0.5rem;
        margin: 0 0.5rem;
        background-color: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: bold;
      }

      .weather-btn:hover {
        background-color: rgba(255, 255, 255, 0.15);
        border-color: var(--primary-color);
      }

      .weather-btn.active {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
        box-shadow: 0 0 15px var(--border-glow);
      }

      /* Time Trial Mode Styles */
      .mode-selector {
        margin: 1rem 0 1.5rem 0;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .mode-buttons {
        display: flex;
        justify-content: center;
        gap: 1rem;
      }

      .mode-btn {
        padding: 0.75rem 1.5rem;
        font-size: 1rem;
        font-weight: bold;
        background-color: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .mode-btn:hover {
        background-color: rgba(255, 255, 255, 0.15);
        border-color: var(--accent-color);
        transform: translateY(-2px);
      }

      .mode-btn.active {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
        box-shadow: 0 0 20px var(--border-glow);
        color: white;
      }

      .time-trial-section {
        margin: 1rem 0;
        padding: 1rem;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .time-trial-section h3 {
        margin: 0 0 1rem 0;
        color: var(--accent-color);
        font-size: 1.1rem;
      }

      .time-trial-buttons {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1rem;
        justify-content: center;
        flex-wrap: wrap;
      }

      .time-trial-btn {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        background-color: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .time-trial-btn:hover {
        background-color: var(--accent-color);
        border-color: var(--accent-color);
      }

      .ghost-list {
        max-height: 150px;
        overflow-y: auto;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        background-color: rgba(0, 0, 0, 0.2);
      }

      .ghost-entry {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        font-size: 0.9rem;
      }

      .ghost-entry:last-child {
        border-bottom: none;
      }

      .ghost-entry span:first-child {
        font-weight: bold;
        color: var(--primary-color);
      }

      .ghost-entry span:nth-child(2) {
        color: var(--accent-color);
        font-family: 'Courier New', monospace;
      }

      .ghost-entry button {
        padding: 0.25rem 0.5rem;
        font-size: 0.8rem;
        background-color: rgba(255, 0, 0, 0.6);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }

      .ghost-entry button:hover {
        background-color: rgba(255, 0, 0, 0.8);
      }

      /* Weather Description Styles */
      .weather-description {
        color: var(--text-secondary);
        font-size: 0.9rem;
        margin-top: 0.5rem;
        min-height: 40px;
      }

      .race-complete {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.95),
          rgba(0, 0, 0, 0.9)
        );
        padding: 2.5rem;
        border-radius: 20px;
        border: 3px solid var(--primary-color);
        text-align: center;
        z-index: 100;
        display: none;
        -webkit-backdrop-filter: blur(15px);
        backdrop-filter: blur(15px);
        box-shadow: 0 16px 64px rgba(0, 0, 0, 0.5);
        width: 450px;
        max-width: 90vw;
      }

      .position-display {
        position: absolute;
        top: 180px;
        right: 20px;
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.9),
          rgba(0, 0, 0, 0.8)
        );
        padding: 1rem;
        border-radius: 8px;
        border-right: 4px solid var(--primary-color);
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        z-index: 10;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        font-family: "Arial", "Helvetica", sans-serif;
        font-weight: 500;
        width: 220px;
        overflow: visible;
      }

      .position-item {
        margin: 0.6rem 0;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        padding: 0.3rem 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        height: 30px; /* Fixed height to prevent vertical growth */
        overflow: hidden;
        white-space: nowrap;
      }

      .position-item span {
        white-space: nowrap;
      }

      .position-item:last-child {
        border-bottom: none;
      }

      .player-pos {
        color: var(--primary-color);
        font-weight: 600;
      }

      .leaderboard {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.95),
          rgba(0, 0, 0, 0.9)
        );
        padding: 1.5rem;
        border-radius: 12px;
        border: 3px solid var(--accent-color);
        z-index: 100;
        width: 300px;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        font-family: "Arial", "Helvetica", sans-serif;
        font-weight: 500;
        display: none; /* Initially hidden, will be shown at end of race */
      }

      .leaderboard h3 {
        margin-bottom: 1rem;
        color: var(--primary-color);
        text-align: center;
        font-size: 1.2rem;
        font-weight: 600;
      }

      .leaderboard-entry {
        margin: 0.6rem 0;
        font-size: 0.85rem;
        display: flex;
        justify-content: space-between;
        padding: 0.5rem;
        border-radius: 8px;
        transition: background 0.2s;
        width: 100%;
        overflow: hidden;
        white-space: nowrap;
        height: 35px; /* Fixed height to prevent vertical growth */
      }

      .leaderboard-entry span:first-child {
        overflow: hidden;
        text-overflow: ellipsis;
        margin-right: 8px;
        flex: 1;
        max-width: 60%;
        white-space: nowrap;
      }

      .leaderboard-entry span:last-child {
        flex: 0 0 auto;
        white-space: nowrap;
      }

      .leaderboard-entry:hover {
        background: rgba(255, 255, 255, 0.05);
      }

      .current-record {
        background: var(--border-glow);
        border: 1px solid var(--primary-color);
        animation: glow 2s ease-in-out infinite alternate;
      }

      @keyframes glow {
        from {
          box-shadow: 0 0 5px var(--border-glow);
        }

        to {
          box-shadow: 0 0 15px var(--border-glow);
        }
      }

      .name-input-modal {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.95),
          rgba(0, 0, 0, 0.9)
        );
        padding: 2.5rem;
        border-radius: 20px;
        border: 3px solid var(--primary-color);
        text-align: center;
        z-index: 200;
        display: none;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(15px);
        box-shadow: 0 16px 64px rgba(0, 0, 0, 0.5);
      }

      .name-input {
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        border: 2px solid var(--primary-color);
        color: var(--text-primary);
        padding: 1rem;
        margin: 1rem;
        border-radius: 12px;
        font-size: 1.1rem;
        text-align: center;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        transition: all 0.3s;
      }

      .name-input:focus {
        outline: none;
        box-shadow: 0 0 20px var(--border-glow);
        border-color: var(--accent-color);
      }

      /* Professional Broadcast-Style Bottom Bar */
      .broadcast-bar {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: linear-gradient(
          90deg,
          rgba(0, 0, 0, 0.95),
          rgba(0, 0, 0, 0.9),
          rgba(0, 0, 0, 0.95)
        );
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(15px);
        border-top: 3px solid var(--primary-color);
        display: none;
        align-items: center;
        justify-content: space-between;
        padding: 0 2rem;
        z-index: 15;
        font-family: "Arial", "Helvetica", sans-serif;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.6);
      }

      .broadcast-section {
        display: flex;
        align-items: center;
        gap: 0.8rem;
        min-width: 120px;
      }

      .broadcast-label {
        color: var(--text-secondary);
        font-size: 0.7rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
        background: rgba(255, 255, 255, 0.1);
        padding: 0.2rem 0.6rem;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .broadcast-value {
        color: var(--text-primary);
        font-size: 1.1rem;
        font-weight: 700;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      }

      .broadcast-dot {
        width: 8px;
        height: 8px;
        background: #ff0000;
        border-radius: 50%;
        animation: livePulse 1.5s ease-in-out infinite;
      }

      @keyframes livePulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }

        50% {
          opacity: 0.6;
          transform: scale(1.2);
        }
      }

      /* Responsive Design and Layout Improvements */
      @media (max-width: 1600px) {
        .game-container {
          padding: 10px;
        }

        #gameCanvas {
          max-width: 90vw;
          max-height: 60vh;
          width: 1400px;
          height: 900px;
        }

        .ui-overlay {
          top: 10px;
          left: 10px;
          font-size: 0.9rem;
          padding: 1rem;
        }

        .controls-info {
          top: 10px;
          right: 10px;
          font-size: 0.8rem;
          padding: 1rem;
        }

        .position-display {
          top: 120px;
          right: 10px;
          width: 200px;
        }

        .leaderboard {
          width: 350px;
        }
      }

      @media (max-width: 1400px) {
        #gameCanvas {
          width: 1200px;
          height: 775px;
          max-width: 85vw;
          max-height: 55vh;
        }

        .title,
        .team-selection-title {
          font-size: 2.8rem;
        }

        .team-selection-subtitle {
          font-size: 1.2rem;
        }

        .team-card {
          width: 320px;
          height: 350px;
        }

        .carousel-nav {
          margin: 0 15px;
        }
      }

      @media (max-width: 1200px) {
        .game-container {
          min-height: 100vh;
          padding: 5px;
        }

        #gameCanvas {
          width: 1000px;
          height: 625px;
          max-width: 90vw;
          max-height: 50vh;
        }

        .team-card {
          width: 280px;
          height: 320px;
          padding: 1.5rem 1rem;
        }

        .team-card.prev,
        .team-card.next {
          transform: translateX(-150px) scale(0.75);
        }

        .team-card.next {
          transform: translateX(150px) scale(0.75);
        }

        .carousel-nav {
          margin: 0 10px;
        }

        .ui-overlay,
        .controls-info,
        .position-display,
        .leaderboard {
          font-size: 0.8rem;
          padding: 0.8rem;
        }

        .broadcast-bar {
          height: 50px;
          padding: 0 1rem;
        }

        .broadcast-value {
          font-size: 1rem;
        }
      }

      /* Text contrast and readability optimizations */
      .ui-item span:first-child {
        color: var(--text-secondary);
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      }

      .ui-item span:last-child {
        color: var(--text-primary);
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      }

      .team-facts .fact-label {
        color: var(--text-secondary);
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      }

      .team-facts .fact-value {
        color: var(--text-primary);
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      }

      .team-name {
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.9);
      }

      .broadcast-label {
        background: rgba(0, 0, 0, 0.8);
        color: var(--text-primary);
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.9);
      }

      .broadcast-value {
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
      }

      /* Better panel backgrounds for readability */
      .ui-overlay,
      .controls-info,
      .position-display,
      .leaderboard {
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.95),
          rgba(0, 0, 0, 0.9)
        );
        border: 1px solid rgba(255, 255, 255, 0.3);
      }

      .team-card {
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.85),
          rgba(0, 0, 0, 0.75)
        );
        border: 2px solid rgba(255, 255, 255, 0.2);
      }

      .team-card.active {
        background: linear-gradient(
          145deg,
          rgba(0, 0, 0, 0.9),
          rgba(0, 0, 0, 0.8)
        );
        border: 2px solid var(--primary-color);
      }

      /* Prevent horizontal overflow */
      body {
        overflow-x: hidden;
        max-width: 100vw;
      }

      .game-container {
        max-width: 100vw;
        overflow-x: hidden;
      }

      /* Better spacing for UI elements */
      .ui-overlay {
        min-width: 200px;
        max-width: 250px;
      }

      .controls-info {
        min-width: 180px;
        max-width: 220px;
      }
    </style>
  </head>

  <body>
    <div class="game-container">
      <!-- Team Selection Screen -->
      <div class="team-selection-screen" id="teamSelectionScreen">
        <h1 class="team-selection-title">EOIN'S RACING GAME</h1>
        <p class="team-selection-subtitle">Select Your Racing Team</p>

        <div class="teams-grid">
          <div class="team-carousel-container">
            <button
              class="carousel-nav prev"
              type="button"
              onclick="previousTeam()"
              onkeydown="if(event.key==='Enter'||event.key===' '){previousTeam();event.preventDefault();}"
              aria-label="Previous Team"
            >
              &#10094;
            </button>

            <div class="team-carousel">
              <!-- Croatian Team - 1 -->
              <div class="team-card active" data-team="adriatic_racing">
                <div class="team-logo">ADR</div>
                <div class="team-name">Adriatic Racing</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Croatia</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2021</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">0</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">2</span>
                  </div>
                </div>
              </div>

              <!-- English Team - 2 -->
              <div class="team-card hidden" data-team="britannia_motors">
                <div class="team-logo">BRT</div>
                <div class="team-name">Britannia Motors</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">England</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2015</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">3</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">28</span>
                  </div>
                </div>
              </div>

              <!-- Chinese Team - 3 -->
              <div class="team-card hidden" data-team="celestial_motors">
                <div class="team-logo">CEM</div>
                <div class="team-name">Celestial Motors</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">China</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2018</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">0</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">4</span>
                  </div>
                </div>
              </div>

              <!-- Welsh Team - 4 -->
              <div class="team-card hidden" data-team="dragon_force">
                <div class="team-logo">DFM</div>
                <div class="team-name">Dragon Force Motorsport</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Wales</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2016</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">1</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">8</span>
                  </div>
                </div>
              </div>

              <!-- Irish Team - 5 -->
              <div class="team-card hidden" data-team="emerald_isle">
                <div class="team-logo">EIR</div>
                <div class="team-name">Emerald Isle Racing</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Ireland</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2018</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">2</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">15</span>
                  </div>
                </div>
              </div>

              <!-- Scottish Team - 6 -->
              <div class="team-card hidden" data-team="highland_racing">
                <div class="team-logo">HRT</div>
                <div class="team-name">Highland Racing Team</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Scotland</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2020</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">0</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">3</span>
                  </div>
                </div>
              </div>

              <!-- Spanish Team - 7 -->
              <div class="team-card hidden" data-team="iberian_speed">
                <div class="team-logo">IBS</div>
                <div class="team-name">Iberian Speed</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Spain</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2019</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">0</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">5</span>
                  </div>
                </div>
              </div>

              <!-- German Team - 8 -->
              <div class="team-card hidden" data-team="kaiser_motorsport">
                <div class="team-logo">KMS</div>
                <div class="team-name">Kaiser Motorsport</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Germany</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2014</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">4</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">35</span>
                  </div>
                </div>
              </div>

              <!-- US Team - 9 -->
              <div class="team-card hidden" data-team="liberty_racing">
                <div class="team-logo">LBR</div>
                <div class="team-name">Liberty Racing</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">USA</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2012</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">1</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">9</span>
                  </div>
                </div>
              </div>

              <!-- Indian Team - 10 -->
              <div class="team-card hidden" data-team="maharaja_motors">
                <div class="team-logo">MHJ</div>
                <div class="team-name">Maharaja Motors</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">India</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2020</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">0</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">1</span>
                  </div>
                </div>
              </div>

              <!-- Japanese Team - 11 -->
              <div class="team-card hidden" data-team="rising_sun">
                <div class="team-logo">RSM</div>
                <div class="team-name">Rising Sun Motors</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Japan</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2016</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">0</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">6</span>
                  </div>
                </div>
              </div>

              <!-- Brazilian Team - 12 -->
              <div class="team-card hidden" data-team="samba_racing">
                <div class="team-logo">SRT</div>
                <div class="team-name">Samba Racing Team</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Brazil</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2011</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">2</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">22</span>
                  </div>
                </div>
              </div>

              <!-- Romanian Team - 13 -->
              <div class="team-card hidden" data-team="regina_curse">
                <div class="team-logo">RGC</div>
                <div class="team-name">Regina Curse</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Romania</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2022</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">0</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">0</span>
                  </div>
                </div>
              </div>

              <!-- French Team - 14 -->
              <div class="team-card hidden" data-team="tricolore_racing">
                <div class="team-logo">TCR</div>
                <div class="team-name">Tricolore Racing</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">France</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2017</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">1</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">12</span>
                  </div>
                </div>
              </div>

              <!-- Venezuelan Team - 15 -->
              <div class="team-card hidden" data-team="velocidad_venezuela">
                <div class="team-logo">VVR</div>
                <div class="team-name">Velocidad Venezuela</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Venezuela</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2021</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">0</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">1</span>
                  </div>
                </div>
              </div>

              <!-- Italian Team - 16 -->
              <div class="team-card hidden" data-team="veloce_italia">
                <div class="team-logo">VIT</div>
                <div class="team-name">Veloce Italia</div>
                <div class="car-livery"></div>
                <div class="team-facts">
                  <div class="fact-row">
                    <span class="fact-label">Country:</span>
                    <span class="fact-value">Italy</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Founded:</span>
                    <span class="fact-value">2013</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Championships:</span>
                    <span class="fact-value">2</span>
                  </div>
                  <div class="fact-row">
                    <span class="fact-label">Wins:</span>
                    <span class="fact-value">18</span>
                  </div>
                </div>
              </div>
            </div>

            <button
              class="carousel-nav next"
              type="button"
              onclick="nextTeam()"
              onkeydown="if(event.key==='Enter'||event.key===' '){nextTeam();event.preventDefault();}"
              aria-label="Next Team"
              tabindex="0"
            >
              &#10095;
            </button>
          </div>
        </div>

        <button
          class="professional-btn"
          id="proceedToRaceBtn"
          onclick="proceedToRace()"
          disabled
        >
          Enter Championship
        </button>
      </div>

      <!-- Start/Race Screen -->
      <div class="start-screen" id="startScreen" style="display: none">
        <h1 class="title">CHAMPIONSHIP READY</h1>
        <p
          style="
            font-size: 1.4rem;
            margin-bottom: 2rem;
            color: var(--text-secondary);
          "
        >
          Grand Prix Circuit Challenge
        </p>
        
        <!-- Game Mode Selector -->
        <div class="mode-selector">
          <div class="mode-buttons">
            <button class="mode-btn active" onclick="setTimeTrialMode(false)" id="raceModeBtn">Race Mode</button>
            <button class="mode-btn" onclick="setTimeTrialMode(true)" id="timeTrialModeBtn">Time Trial</button>
          </div>
        </div>
        
        <button class="professional-btn" onclick="startRace()">
          START RACE
        </button>

        <!-- Time Trial Controls (hidden by default) -->
        <div id="timeTrialControls" style="display: none;">
          <div class="time-trial-section">
            <h3>Ghost Cars</h3>
            <div class="time-trial-buttons">
              <button class="time-trial-btn" onclick="importTimeTrialLap()">Import Ghost</button>
              <button class="time-trial-btn" onclick="clearAllTimeTrialGhosts()">Clear All</button>
            </div>
            <div id="timeTrialGhostList" class="ghost-list"></div>
          </div>
        </div>

        <div class="start-instructions">
          <h3>Race Instructions</h3>
          <p><strong>Controls:</strong> WASD or Arrow Keys to drive</p>
          <p><strong>Boost:</strong> SPACE for Nitro</p>
          <p>
            <strong>Objective:</strong> Complete 3 laps as fast as possible!
          </p>
          <p>Beat the competition and set new lap records!</p>
        </div>
        
        <div class="difficulty-selector">
          <h3>Select Difficulty</h3>
          <div class="difficulty-buttons">
            <button class="difficulty-btn" onclick="setDifficulty('easy')" id="easyBtn">Easy</button>
            <button class="difficulty-btn active" onclick="setDifficulty('medium')" id="mediumBtn">Medium</button>
            <button class="difficulty-btn" onclick="setDifficulty('hard')" id="hardBtn">Hard</button>
          </div>
          <div class="difficulty-description" id="difficultyDescription">
            Standard race settings. AI makes occasional mistakes. Collisions enabled.
          </div>
        </div>
        
        <div class="weather-selector">
          <h3>Select Weather Conditions</h3>
          <div class="weather-buttons">
            <button class="weather-btn active" onclick="setWeather('clear')" id="clearBtn">Clear</button>
            <button class="weather-btn" onclick="setWeather('rain')" id="rainBtn">Rain</button>
            <button class="weather-btn" onclick="setWeather('storm')" id="stormBtn">Storm</button>
          </div>
          <div class="weather-description" id="weatherDescription">
            Perfect racing conditions. Optimal grip and visibility.
          </div>
        </div>
      </div>

      <canvas id="gameCanvas" width="1400" height="900"></canvas>

      <!-- Professional Broadcast-Style Bottom Bar -->
      <div class="broadcast-bar">
        <div class="broadcast-section">
          <div class="broadcast-label">LIVE</div>
          <div class="broadcast-dot"></div>
        </div>
        <div class="broadcast-section">
          <div class="broadcast-label">LAP</div>
          <div class="broadcast-value" id="currentLapDisplay">1/3</div>
        </div>
        <div class="broadcast-section">
          <div class="broadcast-label">RACE TIME</div>
          <div class="broadcast-value" id="raceTimeDisplay">0:00.0</div>
        </div>
        <div class="broadcast-section">
          <div class="broadcast-label">POSITION</div>
          <div class="broadcast-value" id="positionDisplay">P1</div>
        </div>
        <div class="broadcast-section">
          <div class="broadcast-label">SPEED</div>
          <div class="broadcast-value" id="speedDisplay">0 KM/H</div>
        </div>
        <div class="broadcast-section">
          <div class="broadcast-label">CURR LAP</div>
          <div class="broadcast-value" id="currentLapTimeDisplay">0:00.000</div>
        </div>
        <div class="broadcast-section">
          <div class="broadcast-label">BEST LAP</div>
          <div class="broadcast-value" id="bestLapTimeDisplay">-:--:---</div>
        </div>
        <div class="broadcast-section">
          <div class="broadcast-label">LAP RECORD</div>
          <div class="broadcast-value" id="lapRecordDisplay">-:--:---</div>
        </div>
      </div>

      <div class="ui-overlay">
        <div
          style="
            color: var(--primary-color);
            font-weight: 700;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
            border-bottom: 1px solid var(--primary-color);
            padding-bottom: 0.5rem;
          "
        >
          TELEMETRY
        </div>
        <div class="ui-item">
          <span>Speed:</span>
          <span id="speed">0</span>
        </div>
        <div class="ui-item">
          <span>Lap:</span>
          <span id="lap">1/3</span>
        </div>
        <div class="ui-item">
          <span>Time:</span>
          <span id="time">0:00</span>
        </div>
        <div class="ui-item">
          <span>Position:</span>
          <span id="position">1/8</span>
        </div>
        <div class="ui-item">
          <span>Nitro:</span>
          <div
            style="
              width: 100px;
              height: 10px;
              background: rgba(255, 255, 255, 0.3);
              border-radius: 5px;
              position: relative;
            "
          >
            <div
              id="nitroBar"
              style="
                height: 100%;
                background: linear-gradient(
                  90deg,
                  var(--primary-color),
                  var(--accent-color)
                );
                border-radius: 5px;
                width: 100%;
                transition: width 0.1s;
              "
            ></div>
          </div>
        </div>
        <div class="ui-item">
          <span>Tires:</span>
          <div
            style="
              width: 100px;
              height: 10px;
              background: rgba(255, 255, 255, 0.3);
              border-radius: 5px;
              position: relative;
            "
          >
            <div
              id="tireBar"
              style="
                height: 100%;
                background: linear-gradient(90deg, #44ff44, #ffaa44, #ff4444);
                border-radius: 5px;
                width: 100%;
                transition: width 0.1s;
              "
            ></div>
          </div>
        </div>
        <div class="ui-item"></div>
        <div class="ui-item">
          <span>Damage:</span>
          <div
            style="
              width: 100px;
              height: 10px;
              background: rgba(255, 255, 255, 0.3);
              border-radius: 5px;
              position: relative;
            "
          >
            <div
              id="damageBar"
              style="
                height: 100%;
                background: linear-gradient(90deg, #ff4444, #ff8844);
                border-radius: 5px;
                width: 0%;
                transition: width 0.1s;
              "
            ></div>
          </div>
        </div>
      </div>

      <div class="controls-info">
        <div
          style="
            color: var(--accent-color);
            font-weight: 700;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
            border-bottom: 1px solid var(--accent-color);
            padding-bottom: 0.5rem;
          "
        >
          CONTROLS
        </div>
        <p>W/↑ - Accelerate</p>
        <p>S/↓ - Brake</p>
        <p>A/← - Turn Left</p>
        <p>D/→ - Turn Right</p>
        <p>SPACE - Nitro Boost</p>
      </div>

      <div class="position-display">
        <div
          style="
            color: var(--primary-color);
            font-weight: 700;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
            border-bottom: 1px solid var(--primary-color);
            padding-bottom: 0.5rem;
          "
        >
          STANDINGS
        </div>
        <div id="positionList"></div>
      </div>

      <div class="leaderboard">
        <div
          style="
            color: var(--accent-color);
            font-weight: 700;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
            border-bottom: 1px solid var(--accent-color);
            padding-bottom: 0.5rem;
          "
        >
          RECORD TIMES
        </div>
        <div id="leaderboardList"></div>
      </div>

      <div class="name-input-modal" id="nameInputModal">
        <h2 style="color: var(--primary-color); margin-bottom: 1rem">
          NEW RECORD
        </h2>
        <p style="margin-bottom: 1rem; color: var(--text-secondary)">
          Enter your name for the leaderboard:
        </p>
        <input
          type="text"
          id="playerNameInput"
          class="name-input"
          maxlength="12"
          placeholder="Your Name"
        />
        <div
          style="
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
          "
        >
          <button class="professional-btn" onclick="saveLeaderboardEntry()">
            SAVE TIME
          </button>
          <button class="professional-btn" onclick="skipLeaderboard()">
            SKIP
          </button>
        </div>
      </div>

      <div class="race-complete" id="raceComplete">
        <h2 style="color: var(--primary-color); margin-bottom: 1rem">
          RACE COMPLETE
        </h2>
        <p style="font-size: 1.2rem; margin: 0.5rem 0">
          Final Position:
          <span
            id="finalPos"
            style="color: var(--accent-color); font-weight: bold"
          ></span>
        </p>
        <p style="font-size: 1.2rem; margin: 0.5rem 0">
          Total Time:
          <span
            id="finalTime"
            style="color: var(--text-primary); font-weight: bold"
          ></span>
        </p>
        <p style="font-size: 1.2rem; margin: 0.5rem 0">
          Best Lap:
          <span
            id="bestLapTime"
            style="color: var(--accent-color); font-weight: bold"
          ></span>
        </p>
        <p style="font-size: 1.2rem; margin: 0.5rem 0">
          Lap Record:
          <span
            id="lapRecordTime"
            style="color: var(--primary-color); font-weight: bold"
          ></span>
        </p>
        <p
          id="newRecordText"
          style="
            color: var(--accent-color);
            font-weight: bold;
            display: none;
            margin: 1rem 0;
          "
        >
          NEW RECORD
        </p>

        <!-- Embedded Leaderboard -->
        <div
          style="
            margin: 1rem 0;
            max-height: 200px;
            overflow-y: auto;
            width: 100%;
          "
        >
          <div
            style="
              color: var(--accent-color);
              font-weight: 700;
              margin-bottom: 0.5rem;
              text-transform: uppercase;
              letter-spacing: 1px;
              font-size: 0.9rem;
              border-bottom: 1px solid var(--accent-color);
              padding-bottom: 0.5rem;
            "
          >
            RECORD TIMES
          </div>
          <div id="raceCompleteLeaderboard"></div>
        </div>

        <div
          style="
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
          "
        >
          <button class="professional-btn" onclick="restartRace()">
            RACE AGAIN
          </button>
          <button class="professional-btn" onclick="returnToTeamSelection()">
            CHANGE TEAM
          </button>
        </div>
      </div>

      <!-- Time Trial Complete Dialog -->
      <div class="race-complete" id="timeTrialComplete" style="display: none;">
        <h2 style="color: var(--primary-color); margin-bottom: 1rem">
          TIME TRIAL COMPLETE
        </h2>
        <p style="font-size: 1.2rem; margin: 0.5rem 0">
          Lap Time:
          <span
            id="timeTrialLapTime"
            style="color: var(--accent-color); font-weight: bold"
          ></span>
        </p>
        <p
          id="timeTrialResult"
          style="
            color: var(--accent-color);
            font-weight: bold;
            font-size: 1.1rem;
            margin: 1rem 0;
          "
        ></p>

        <div
          style="
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
          "
        >
          <button class="professional-btn" onclick="restartRace()">
            TRY AGAIN
          </button>
          <button class="professional-btn" onclick="returnToTeamSelection()">
            CHANGE TEAM
          </button>
        </div>
      </div>
    </div>

    <script>
      // Team themes configuration with high contrast
      const teamThemes = {
        // Croatian Team - Red, White, Blue
        adriatic_racing: {
          "--primary-color": "#FF0000",
          "--accent-color": "#0066CC",
          "--bg-primary": "#1a0a0a",
          "--bg-secondary": "#2a1a1a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#ffaaaa",
          "--border-glow": "rgba(255, 0, 0, 0.4)",
        },
        // English Team - Dark Blue and Silver
        britannia_motors: {
          "--primary-color": "#191970",
          "--accent-color": "#C0C0C0",
          "--bg-primary": "#0a0a1a",
          "--bg-secondary": "#1a1a2a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#aaaaff",
          "--border-glow": "rgba(25, 25, 112, 0.4)",
        },
        // Chinese Team - Gold and Black
        celestial_motors: {
          "--primary-color": "#FFD700",
          "--accent-color": "#1C1C1C",
          "--bg-primary": "#1a1a0a",
          "--bg-secondary": "#2a2a1a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#ffcc88",
          "--border-glow": "rgba(255, 215, 0, 0.4)",
        },
        // Welsh Team - Red and Gold
        dragon_force: {
          "--primary-color": "#DC143C",
          "--accent-color": "#FFD700",
          "--bg-primary": "#1a0a0a",
          "--bg-secondary": "#2a1a1a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#ffaaaa",
          "--border-glow": "rgba(220, 20, 60, 0.4)",
        },
        // Irish Team - Green and Orange
        emerald_isle: {
          "--primary-color": "#228B22",
          "--accent-color": "#FF8C00",
          "--bg-primary": "#0a1a0a",
          "--bg-secondary": "#1a2a1a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#88ff88",
          "--border-glow": "rgba(34, 139, 34, 0.4)",
        },
        // Scottish Team - Blue and White
        highland_racing: {
          "--primary-color": "#003DA5",
          "--accent-color": "#FFFFFF",
          "--bg-primary": "#0a0a1a",
          "--bg-secondary": "#1a1a2a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#88aaff",
          "--border-glow": "rgba(0, 61, 165, 0.4)",
        },
        // Spanish Team - Red and Yellow
        iberian_speed: {
          "--primary-color": "#C60B1E",
          "--accent-color": "#FFC400",
          "--bg-primary": "#0a0a0a",
          "--bg-secondary": "#2a1a1a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#ffaaaa",
          "--border-glow": "rgba(198, 11, 30, 0.4)",
        },
        // German Team - Black and Red with Orange accents
        kaiser_motorsport: {
          "--primary-color": "#FF4500",
          "--accent-color": "#000000",
          "--bg-primary": "#1a0a0a",
          "--bg-secondary": "#2a1a1a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#ffaa66",
          "--border-glow": "rgba(255, 69, 0, 0.4)",
        },
        // US Team - Navy and Red with White accents
        liberty_racing: {
          "--primary-color": "#002868",
          "--accent-color": "#FFFFFF",
          "--bg-primary": "#0a0a1a",
          "--bg-secondary": "#1a1a2a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#aaaaff",
          "--border-glow": "rgba(0, 40, 104, 0.4)",
        },
        // Indian Team - Saffron and Green with Blue accents
        maharaja_motors: {
          "--primary-color": "#FF9933",
          "--accent-color": "#000080",
          "--bg-primary": "#1a1a0a",
          "--bg-secondary": "#2a2a1a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#ffcc88",
          "--border-glow": "rgba(255, 153, 51, 0.4)",
        },
        // Brazilian Team - Green and Yellow
        samba_racing: {
          "--primary-color": "#009739",
          "--accent-color": "#FEDD00",
          "--bg-primary": "#0a1a0a",
          "--bg-secondary": "#1a2a1a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#88ff88",
          "--border-glow": "rgba(0, 151, 57, 0.4)",
        },
        // Romanian Team - Pink
        regina_curse: {
          "--primary-color": "#FF69B4",
          "--accent-color": "#FFB6C1",
          "--bg-primary": "#1a0a0a",
          "--bg-secondary": "#2a1a2a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#ffaad5",
          "--border-glow": "rgba(255, 105, 180, 0.4)",
        },
        // French Team - Blue and Red with White accents
        tricolore_racing: {
          "--primary-color": "#0055A4",
          "--accent-color": "#FFFFFF",
          "--bg-primary": "#0a0a1a",
          "--bg-secondary": "#1a1a2a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#88aaff",
          "--border-glow": "rgba(0, 85, 164, 0.4)",
        },
        // Japanese Team - Red and White with Black accents
        rising_sun: {
          "--primary-color": "#BC002D",
          "--accent-color": "#000000",
          "--bg-primary": "#1a0a0a",
          "--bg-secondary": "#2a1a2a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#ffaaaa",
          "--border-glow": "rgba(188, 0, 45, 0.4)",
        },
        // Venezuelan Team - Yellow, Blue, Red
        velocidad_venezuela: {
          "--primary-color": "#FFCC00",
          "--accent-color": "#003DA5",
          "--bg-primary": "#1a0a0a",
          "--bg-secondary": "#2a1a2a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#ffcc88",
          "--border-glow": "rgba(255, 204, 0, 0.4)",
        },
        // Italian Team - Green, White, Red
        veloce_italia: {
          "--primary-color": "#009246",
          "--accent-color": "#CE2B37",
          "--bg-primary": "#1a0a0a",
          "--bg-secondary": "#2a2a1a",
          "--text-primary": "#ffffff",
          "--text-secondary": "#88ff88",
          "--border-glow": "rgba(0, 146, 70, 0.4)",
        },
      };

      let selectedTeam = null;
      let currentTeamIndex = 0;
      const teams = [
        "adriatic_racing",
        "britannia_motors",
        "celestial_motors",
        "dragon_force",
        "emerald_isle",
        "highland_racing",
        "iberian_speed",
        "kaiser_motorsport",
        "liberty_racing",
        "maharaja_motors",
        "rising_sun",
        "samba_racing",
        "regina_curse",
        "tricolore_racing",
        "velocidad_venezuela",
        "veloce_italia",
      ];

      // Team selection functionality
      function initializeTeamSelection() {
        updateCarousel();
        populateTeamAttributes();
      }

      function populateTeamAttributes() {
        const teamCards = document.querySelectorAll(".team-card");

        teamCards.forEach((card) => {
          const teamKey = card.getAttribute("data-team");
          const teamMapping = {
            emerald_isle: "Emerald Isle Racing",
            dragon_force: "Dragon Force Motorsport",
            highland_racing: "Highland Racing Team",
            britannia_motors: "Britannia Motors",
            tricolore_racing: "Tricolore Racing",
            kaiser_motorsport: "Kaiser Motorsport",
            iberian_speed: "Iberian Speed",
            veloce_italia: "Veloce Italia",
            adriatic_racing: "Adriatic Racing",
            liberty_racing: "Liberty Racing",
            rising_sun: "Rising Sun Motors",
            celestial_motors: "Celestial Motors",
            maharaja_motors: "Maharaja Motors",
            samba_racing: "Samba Racing Team",
            velocidad_venezuela: "Velocidad Venezuela",
            regina_curse: "Regina Curse",
          };

          const teamName = teamMapping[teamKey];
          const teamData = aiTeams.find((team) => team.name === teamName);

          if (teamData) {
            // Add attributes container if it doesn't exist
            let attributesContainer = card.querySelector(".team-attributes");
            if (!attributesContainer) {
              attributesContainer = document.createElement("div");
              attributesContainer.className = "team-attributes";
              card.appendChild(attributesContainer);
            }

            // Create attributes HTML
            const attributeNames = {
              speed: "Speed",
              acceleration: "Acceleration",
              handling: "Handling",
              braking: "Braking",
              reliability: "Reliability",
              tireManagement: "Tire Mgmt",
            };

            let attributesHTML =
              '<div class="attributes-title">Team Attributes</div>';

            Object.entries(attributeNames).forEach(([key, displayName]) => {
              const value = teamData.attributes[key];
              const percentage = (value / 20) * 100; // Scale to 0-100%

              attributesHTML += `
                            <div class="attribute-row">
                                <span class="attribute-name">${displayName}</span>
                                <div class="attribute-bar">
                                    <div class="attribute-fill" style="width: ${percentage}%"></div>
                                </div>
                                <span class="attribute-value">${value}</span>
                            </div>
                        `;
            });

            attributesContainer.innerHTML = attributesHTML;
          }
        });
      }

      function updateCarousel() {
        const teamCards = document.querySelectorAll(".team-card");
        const currentTeam = teams[currentTeamIndex];

        teamCards.forEach((card) => {
          const cardTeam = card.getAttribute("data-team");
          card.classList.remove("active", "prev", "next", "hidden");

          if (cardTeam === currentTeam) {
            card.classList.add("active");
          } else if (
            cardTeam ===
            teams[(currentTeamIndex - 1 + teams.length) % teams.length]
          ) {
            card.classList.add("prev");
          } else if (
            cardTeam === teams[(currentTeamIndex + 1) % teams.length]
          ) {
            card.classList.add("next");
          } else {
            card.classList.add("hidden");
          }
        });

        // Apply theme of current team
        applyTeamTheme(currentTeam);

        // Auto-select the current team
        selectCurrentTeam();

        // Update attributes display
        populateTeamAttributes();
      }

      function nextTeam() {
        currentTeamIndex = (currentTeamIndex + 1) % teams.length;
        updateCarousel();
      }

      function previousTeam() {
        currentTeamIndex = (currentTeamIndex - 1 + teams.length) % teams.length;
        updateCarousel();
      }

      function selectCurrentTeam() {
        selectedTeam = teams[currentTeamIndex];
        document.getElementById("proceedToRaceBtn").disabled = false;

        // Add selection visual feedback
        const activeCard = document.querySelector(".team-card.active");
        activeCard.style.borderColor = "var(--accent-color)";
        activeCard.style.boxShadow = "0 0 30px var(--border-glow)";
      }

      function applyTeamTheme(teamKey) {
        const theme = teamThemes[teamKey];
        const root = document.documentElement;

        Object.keys(theme).forEach((property) => {
          root.style.setProperty(property, theme[property]);
        });
      }

      function proceedToRace() {
        if (!selectedTeam) return;

        // Map selectedTeam (key) to actual team name and find the corresponding aiTeam
        const teamMapping = {
          emerald_isle: "Emerald Isle Racing",
          dragon_force: "Dragon Force Motorsport",
          highland_racing: "Highland Racing Team",
          britannia_motors: "Britannia Motors",
          tricolore_racing: "Tricolore Racing",
          kaiser_motorsport: "Kaiser Motorsport",
          iberian_speed: "Iberian Speed",
          veloce_italia: "Veloce Italia",
          adriatic_racing: "Adriatic Racing",
          liberty_racing: "Liberty Racing",
          rising_sun: "Rising Sun Motors",
          celestial_motors: "Celestial Motors",
          maharaja_motors: "Maharaja Motors",
          samba_racing: "Samba Racing Team",
          velocidad_venezuela: "Velocidad Venezuela",
          regina_curse: "Regina Curse",
        };

        const teamName = teamMapping[selectedTeam];
        const teamData = aiTeams.find((team) => team.name === teamName);
        if (teamData) {
          // Set player car color to match selected team
          player.color = teamData.color;

          // Apply team attributes to player car
          player.teamAttributes = teamData.attributes;

          // Calculate performance multipliers from team attributes (1-20 scale converted to meaningful multipliers)
          // Each team attribute affects different aspects of car performance
          // Apply the same multipliers as AI cars for consistency
          const playerMultiplier = difficultySettings[gameDifficulty].playerAttributeMultiplier;
          const speedMultiplier = (1.0 + (teamData.attributes.speed / 20) * 1.0) * playerMultiplier; // Max speed scaling
          const accelMultiplier = (1.0 + (teamData.attributes.acceleration / 20) * 1.0) * playerMultiplier; // Acceleration force scaling
          const handlingMultiplier = (1.0 + (teamData.attributes.handling / 20) * 1.0) * playerMultiplier; // Turn rate scaling
          const brakingMultiplier = (1.0 + (teamData.attributes.braking / 20) * 1.0) * playerMultiplier; // Braking force scaling
          const reliabilityMultiplier = (0.8 + (teamData.attributes.reliability / 20) * 0.4) * playerMultiplier; // Damage resistance (0.8-1.2)
          const tireMultiplier = (0.8 + (teamData.attributes.tireManagement / 20) * 0.4) * playerMultiplier; // Tire wear reduction (0.8-1.2)

          // Apply calculated multipliers to base car performance stats
          player.maxSpeed = player.baseMaxSpeed * speedMultiplier;
          player.acceleration = player.baseAcceleration * accelMultiplier;
          player.turnSpeed = player.baseTurnSpeed * handlingMultiplier;
          player.friction = player.baseFriction * brakingMultiplier;
          player.brakingPower = (player.baseBrakingPower || 0.15) * brakingMultiplier;

          // Tire and reliability systems
          player.tireWearRate = 0.4 / tireMultiplier; // Better tire management = slower wear
          player.reliabilityFactor = reliabilityMultiplier; // Affects damage susceptibility

          // Ensure lap timing and race progress tracking are properly initialized
          player.lapTimes = [];
          player.currentLapStartTime = 0;
          player.totalRaceTime = 0;
          player.checkpointTimes = {};
          player.calculatedTotalTime = 0;
        }

        // Hide broadcast bar on start screen
        document.querySelector(".broadcast-bar").style.display = "none";

        document.getElementById("teamSelectionScreen").style.display = "none";
        document.getElementById("startScreen").style.display = "flex";
      }

      // Game setup
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      /**
       * Camera System for Smooth Player Following
       * Provides smooth camera movement that follows the player car with configurable lag.
       * Prevents jarring camera movements while maintaining responsive tracking.
       */
      const camera = {
        x: 0, // Current camera world X position
        y: 0, // Current camera world Y position
        targetX: 0, // Target X position (where camera wants to be)
        targetY: 0, // Target Y position (where camera wants to be)
        smoothing: 0.1, // Camera smoothing factor (0.1 = 10% movement per frame)
      };

      /**
       * Updates camera target position and applies smooth interpolation.
       * Called every frame to track player movement with natural lag.
       */
      function updateCamera() {
        // Set camera target to center player on screen
        camera.targetX = player.x - canvas.width / 2;
        camera.targetY = player.y - canvas.height / 2;

        // Apply smooth interpolation to prevent jarring movement
        camera.x += (camera.targetX - camera.x) * camera.smoothing;
        camera.y += (camera.targetY - camera.y) * camera.smoothing;
      }

      /**
       * Applies camera transformation matrix to canvas context.
       * All subsequent drawing will be offset by camera position.
       */
      function applyCameraTransform() {
        ctx.save();
        ctx.translate(-camera.x, -camera.y);
      }

      /**
       * Removes camera transformation from canvas context.
       * Used before drawing UI elements that should remain screen-fixed.
       */
      function resetCameraTransform() {
        ctx.restore();
      }

      // Game state
      let gameRunning = false;
      let raceStartTime = 0;
      let currentLap = 1;
      let totalLaps = 5;
      let raceComplete = false;
      let currentRaceTime = 0;
      
      // Difficulty settings
      let gameDifficulty = "medium"; // "easy", "medium", "hard"
      
      // Weather settings
      let gameWeather = "clear"; // "clear", "rain", "storm"
      
      // Time Trial mode settings
      let isTimeTrialMode = false;
      let isRecordingGhost = false;
      let currentGhostRecording = [];
      let timeTrialGhosts = [];
      let timeTrialLaps = [];
      let bestTimeTrialLap = null;
      
      const difficultySettings = {
        easy: {
          aiAttributeMultiplier: 0.85, // AI cars have reduced attributes
          playerAttributeMultiplier: 1.0, // Player attributes unchanged
          collisionsEnabled: false, // No collisions on Easy
          aiMistakesEnabled: true, // AI makes mistakes
          aiMistakeFrequency: 1.5, // Higher frequency of mistakes
          aiReactionTime: 1.3 // Slower reaction time
        },
        medium: {
          aiAttributeMultiplier: 1.0, // Normal AI attributes
          playerAttributeMultiplier: 1.0, // Normal player attributes
          collisionsEnabled: true, // Collisions enabled
          aiMistakesEnabled: true, // AI makes mistakes
          aiMistakeFrequency: 1.0, // Normal mistake frequency
          aiReactionTime: 1.0 // Normal reaction time
        },
        hard: {
          aiAttributeMultiplier: 1.15, // Enhanced AI attributes
          playerAttributeMultiplier: 1.0, // Player attributes unchanged
          collisionsEnabled: true, // Collisions enabled
          aiMistakesEnabled: false, // AI doesn't make mistakes
          aiReactionTime: 0.7 // Faster reaction time
        }
      };

      // Lap timing variables
      let lapStartTime = 0;
      let currentLapTime = 0;
      let bestLapTime = Number.MAX_VALUE; // Best lap time in current race
      let lapRecord = Number.MAX_VALUE; // All-time best lap (persists between races)
      let lastLapTime = 0; // Last completed lap time
      let lapTimes = [];

      // Initialize team selection on page load
      document.addEventListener("DOMContentLoaded", () => {
        initializeTeamSelection();
        // Set default theme to the first available team (Adriatic Racing)
        applyTeamTheme("adriatic_racing");
        
        // Initialize difficulty selector with medium selected
        setDifficulty("medium");
        
        // Initialize weather selector with clear weather selected
        setWeather("clear");
        
        // Initialize mode UI (race mode by default)
        updateModeUI();
      });

      // Leaderboard system
      let leaderboard = JSON.parse(
        localStorage.getItem("circuitRacerLeaderboard") || "[]"
      );

      function saveLeaderboardEntry() {
        const playerName = document
          .getElementById("playerNameInput")
          .value.trim();
        if (playerName === "") {
          alert("Please enter your name!");
          return;
        }

        const entry = {
          name: playerName,
          time: currentRaceTime,
          position: player.racePosition,
          date: new Date().toLocaleDateString(),
          weather: gameWeather, // Add weather information
          difficulty: gameDifficulty, // Add difficulty information too
          team: getSelectedTeamName() // Add team information
        };

        leaderboard.push(entry);
        leaderboard.sort((a, b) => a.time - b.time);
        leaderboard = leaderboard.slice(0, 10); // Keep top 10

        localStorage.setItem(
          "circuitRacerLeaderboard",
          JSON.stringify(leaderboard)
        );
        updateLeaderboardDisplay();
        updateRaceCompleteLeaderboard();

        // Clear the input field
        document.getElementById("playerNameInput").value = "";

        document.getElementById("nameInputModal").style.display = "none";
        document.getElementById("raceComplete").style.display = "block";
      }

      function skipLeaderboard() {
        document.getElementById("nameInputModal").style.display = "none";
        document.getElementById("raceComplete").style.display = "block";
      }
      
      // Difficulty selection functionality
      function setDifficulty(level) {
        // Update the game difficulty
        gameDifficulty = level;
        
        // Update UI
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.getElementById(level + 'Btn').classList.add('active');
        
        // Update description
        const descriptionElement = document.getElementById('difficultyDescription');
        if (level === 'easy') {
          descriptionElement.textContent = 'Beginner friendly. Collisions disabled. AI makes more mistakes and has reduced performance.';
        } else if (level === 'medium') {
          descriptionElement.textContent = 'Standard race settings. AI makes occasional mistakes. Collisions enabled.';
        } else if (level === 'hard') {
          descriptionElement.textContent = 'Challenge mode. AI doesn\'t make mistakes and has enhanced performance. Collisions enabled.';
        }
      }

      // Weather selection functionality
      function setWeather(type) {
        // Update the game weather
        gameWeather = type;
        
        // Update UI
        document.querySelectorAll('.weather-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.getElementById(type + 'Btn').classList.add('active');
        
        // Update description
        const descriptionElement = document.getElementById('weatherDescription');
        if (type === 'clear') {
          descriptionElement.textContent = 'Perfect racing conditions. Optimal grip and visibility.';
        } else if (type === 'rain') {
          descriptionElement.textContent = 'Wet track conditions. Reduced grip and limited visibility. Careful with acceleration and braking.';
        } else if (type === 'storm') {
          descriptionElement.textContent = 'Severe weather. Heavy rain with very poor visibility. Extremely challenging driving conditions.';
        }
        
        // Initialize rain particles if weather has particles
        if (weatherEffects[type].particles) {
          initializeRainParticles();
        }
      }

      // Time Trial mode selection functionality
      function toggleTimeTrialMode() {
        isTimeTrialMode = !isTimeTrialMode;
        updateModeUI();
      }
      
      function setTimeTrialMode(enabled) {
        isTimeTrialMode = enabled;
        updateModeUI();
      }
      
      function updateModeUI() {
        // Update UI
        document.querySelectorAll('.mode-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        
        const timeTrialControls = document.getElementById('timeTrialControls');
        const difficultySelector = document.querySelector('.difficulty-selector');
        
        if (isTimeTrialMode) {
          document.getElementById('timeTrialModeBtn').classList.add('active');
          if (timeTrialControls) {
            timeTrialControls.style.display = 'block';
          }
          // Hide difficulty selector in time trial mode
          if (difficultySelector) {
            difficultySelector.style.display = 'none';
          }
        } else {
          document.getElementById('raceModeBtn').classList.add('active');
          if (timeTrialControls) {
            timeTrialControls.style.display = 'none';
          }
          // Show difficulty selector in race mode
          if (difficultySelector) {
            difficultySelector.style.display = 'block';
          }
        }
      }

      function updateRaceCompleteLeaderboard() {
        const list = document.getElementById("raceCompleteLeaderboard");
        list.innerHTML = "";

        leaderboard.forEach((entry, index) => {
          const div = document.createElement("div");
          div.className = "leaderboard-entry";
          if (
            entry.time === currentRaceTime &&
            entry.name === document.getElementById("playerNameInput").value
          ) {
            div.className += " current-record";
          }

          const minutes = Math.floor(entry.time / 60);
          const seconds = (entry.time % 60).toFixed(3);

          // Shorten car name to first two words if it's too long
          let displayName = entry.name;
          const words = displayName.split(" ");
          if (words.length > 2) {
            displayName = words.slice(0, 2).join(" ");
          }

          // Get weather info with default for older entries
          const weatherDisplay = getWeatherDisplay(entry.weather || 'clear');
          const difficultyDisplay = getDifficultyDisplay(entry.difficulty || 'medium');
          const teamDisplay = getTeamDisplayName(entry.team);

          div.innerHTML = `
                    <span style="width: 20px; display: inline-block;">${index + 1}.</span>
                    <span style="width: 90px; display: inline-block;">${displayName}</span>
                    <span style="width: 40px; display: inline-block; font-size: 0.8em; color: var(--accent-color);">${teamDisplay}</span>
                    <span style="width: 80px; display: inline-block;">${minutes}:${seconds.padStart(6, "0")}</span>
                    <span style="width: 30px; display: inline-block; font-size: 0.9em;">${weatherDisplay}</span>
                    <span style="width: 30px; display: inline-block; font-size: 0.8em; color: #888;">${difficultyDisplay}</span>
                `;
          list.appendChild(div);
        });
      }

      function updateLeaderboardDisplay() {
        const list = document.getElementById("leaderboardList");
        list.innerHTML = "";

        leaderboard.forEach((entry, index) => {
          const div = document.createElement("div");
          div.className = "leaderboard-entry";
          if (
            entry.time === currentRaceTime &&
            entry.name === document.getElementById("playerNameInput").value
          ) {
            div.className += " current-record";
          }

          const minutes = Math.floor(entry.time / 60);
          const seconds = (entry.time % 60).toFixed(3);

          // Truncate names that are too long (over 12 characters)
          let displayName = entry.name;
          if (displayName.length > 10) {
            displayName = displayName.substring(0, 8) + "...";
          }

          // Get weather info with default for older entries
          const weatherDisplay = getWeatherDisplay(entry.weather || 'clear');
          const difficultyDisplay = getDifficultyDisplay(entry.difficulty || 'medium');
          const teamDisplay = getTeamDisplayName(entry.team);

          div.innerHTML = `
                    <span style="width: 15px; display: inline-block;">${index + 1}.</span>
                    <span style="width: 65px; display: inline-block;">${displayName}</span>
                    <span style="width: 30px; display: inline-block; font-size: 0.8em; color: var(--accent-color);">${teamDisplay}</span>
                    <span style="width: 70px; display: inline-block;">${minutes}:${seconds.padStart(6, "0")}</span>
                    <span style="width: 25px; display: inline-block; font-size: 0.8em;">${weatherDisplay}</span>
                    <span style="width: 25px; display: inline-block; font-size: 0.7em; color: #888;">${difficultyDisplay}</span>
                `;
          list.appendChild(div);
        });
      }

      // Helper functions for leaderboard display
      function getWeatherDisplay(weather) {
        switch(weather) {
          case 'clear': return '';
          case 'rain': return '(w)';
          case 'storm': return '(vw)';
          default: return '';
        }
      }

      function getDifficultyDisplay(difficulty) {
        switch(difficulty) {
          case 'easy': return 'E';
          case 'medium': return 'M';
          case 'hard': return 'H';
          default: return 'M';
        }
      }

      function getTeamDisplayName(teamName) {
        if (!teamName) return '';
        // Create short team codes for display
        const teamCodes = {
          'Emerald Isle Racing': 'EIR',
          'Dragon Force Motorsport': 'DFM',
          'Highland Racing Team': 'HRT',
          'Britannia Motors': 'BRT',
          'Tricolore Racing': 'TCR',
          'Kaiser Motorsport': 'KMS',
          'Iberian Speed': 'IBS',
          'Veloce Italia': 'VIT',
          'Adriatic Racing': 'ADR',
          'Liberty Racing': 'LBR',
          'Rising Sun Motors': 'RSM',
          'Celestial Motors': 'CEL',
          'Maharaja Motors': 'MHJ',
          'Samba Racing Team': 'SRT',
          'Velocidad Venezuela': 'VEV',
          'Regina Curse': 'RGC'
        };
        return teamCodes[teamName] || teamName.substring(0, 3).toUpperCase();
      }

      function isNewRecord(time) {
        return (
          leaderboard.length < 10 ||
          time < leaderboard[leaderboard.length - 1].time
        );
      }

      // Input handling
      const keys = {};
      document.addEventListener("keydown", (e) => {
        keys[e.code] = true;

        // Carousel navigation in team selection screen
        if (
          document.getElementById("teamSelectionScreen").style.display !==
          "none"
        ) {
          if (e.code === "ArrowLeft") {
            e.preventDefault();
            previousTeam();
          } else if (e.code === "ArrowRight") {
            e.preventDefault();
            nextTeam();
          } else if (e.code === "Enter" && selectedTeam) {
            e.preventDefault();
            proceedToRace();
          }
        }

        // Start race with spacebar in start screen
        if (document.getElementById("startScreen").style.display !== "none") {
          if (e.code === "Space") {
            e.preventDefault();
            startRace();
          }
        }
      });
      document.addEventListener("keyup", (e) => {
        keys[e.code] = false;
      });

      // Track design - Larger proper circuit with start/finish at middle bottom
      const track = {
        waypoints: [
          // Fillte Faoi Dheireadh (Final Return) - Last turn before start/finish
          { x: 1000, y: 1300, checkpoint: true },
          { x: 1000, y: 1220 },
          { x: 1000, y: 1140 },

          // Droim Gealáin (Back Straight Ridge) - Long back straight section
          { x: 1080, y: 1060, checkpoint: true },
          { x: 1200, y: 980 },
          { x: 1350, y: 900 },
          { x: 1480, y: 820 },

          // Géarchasadh Coscán (Sharp Brake Turn) - Sharp left corner
          { x: 1650, y: 750, checkpoint: true },
          { x: 1800, y: 680 },
          { x: 1920, y: 600 },
          { x: 2020, y: 520 },

          // Cúinne Tír (Land Corner) - Medium left hander
          { x: 2100, y: 450, checkpoint: true },
          { x: 2150, y: 350 },
          { x: 2170, y: 250 },
          { x: 2160, y: 150 },

          // Zigzag na gCarr (Car Zigzag) - Technical chicane section
          { x: 2120, y: 80, checkpoint: true },
          { x: 2000, y: 50 },
          { x: 1850, y: 70 },
          { x: 1700, y: 120 },

          // Scuabaí Fada (Long Sweep) - Long left sweep down
          { x: 1550, y: 180, checkpoint: true },
          { x: 1400, y: 250 },
          { x: 1280, y: 330 },
          { x: 1180, y: 420 },

          // Cúinne an Fhilleadh (Hairpin Corner) - Tight hairpin at top
          { x: 1100, y: 500, checkpoint: true },
          { x: 1000, y: 580 },
          { x: 900, y: 660 },
          { x: 820, y: 740 },

          // Géarchodadh Roth (Sharp Wheel Turn) - Sharp right at top section
          { x: 750, y: 820, checkpoint: true },
          { x: 650, y: 900 },
          { x: 520, y: 980 },
          { x: 380, y: 1050 },

          // Leantóir Gaoithe (Wind Follower) - Fast sweeping right
          { x: 250, y: 1120, checkpoint: true },
          { x: 180, y: 1200 },
          { x: 150, y: 1300 },
          { x: 180, y: 1400 },

          // Casadh Luais (Speed Corner) - Long right hander
          { x: 250, y: 1480, checkpoint: true },
          { x: 350, y: 1520 },
          { x: 480, y: 1540 },
          { x: 620, y: 1550 },

          // Start/finish line approach - First turn of the track
          { x: 750, y: 1540, checkpoint: true },
          { x: 850, y: 1520 },
          { x: 920, y: 1480 },
          { x: 960, y: 1420 },
          { x: 980, y: 1360 },
        ],
        width: 160,
        // Checkpoint system for lap counting
        checkpoints: [
          { id: 0, x: 1000, y: 1300, name: "Tosach/Críoch" }, // Start/Finish in Irish
          { id: 1, x: 2100, y: 450, name: "Géarchodadh Roth" }, // Sharp Wheel Turn
          { id: 2, x: 250, y: 1120, name: "Géarchasadh Coscán" }, // Sharp Brake Turn
        ],
      };

      // Player car with team attributes and damage system
      // Player car object - Contains all player car state and physics properties
      const player = {
        // Position and orientation
        x: 1000, // X coordinate on track
        y: 1350, // Y coordinate - positioned BEHIND the start/finish line (which is at y=1300)
        angle: -Math.PI / 2, // Car direction in radians (pointing upward initially)
        velocity: { x: 0, y: -0.1 }, // Current velocity vector with small initial upward motion
        speed: 0, // Magnitude of velocity for display purposes

        // Base performance stats (before team modifications)
        baseMaxSpeed: 8.0, // Maximum achievable speed
        baseAcceleration: 0.22, // Acceleration force per frame
        baseFriction: 0.96, // Velocity decay factor (higher = less friction)
        baseTurnSpeed: 0.04, // Angular velocity multiplier for steering

        // Current performance stats (affected by team attributes and damage)
        maxSpeed: 8.0, // Current maximum speed (affected by team/damage)
        acceleration: 0.22, // Current acceleration rate
        friction: 0.96, // Current friction level
        turnSpeed: 0.04, // Current turning sensitivity

        // Visual and collision properties
        size: 20, // Car hitbox size for collision detection
        color: "#ff0000", // Car color (set by team selection)

        // Race progress tracking
        currentCheckpoint: 1, // Next checkpoint to hit (0=start/finish, 1=sector1, 2=sector2)
        checkpointsHit: [true, false, false], // Boolean array tracking which checkpoints have been hit this lap
        lapProgress: 0,
        lapsCompleted: 0,
        racePosition: 1,
        nitro: 100,
        maxNitro: 100,
        usingNitro: false,
        nitroRegenRate: 0.35,
        // Team attributes and damage system
        teamAttributes: null, // Will be set when team is selected
        damage: {
          speed: 0, // 0-100, reduces maxSpeed
          acceleration: 0, // 0-100, reduces acceleration
          handling: 0, // 0-100, reduces turnSpeed and increases instability
          braking: 0, // 0-100, reduces braking effectiveness
          visible: false, // Whether damage effects are visible
        },
        // Tire management (affected by team attributes)
        tireWear: 0, // 0-100, affects grip over time
        tireWearRate: 0.4, // Rate of tire degradation per frame
        reliabilityFactor: 1.0, // Affects chance of mechanical failures
        lastCollisionTime: 0,
        // Lap time tracking for accurate gap calculation
        lapTimes: [], // Array of completed lap times in seconds
        currentLapStartTime: 0, // When current lap started
        totalRaceTime: 0, // Sum of all completed lap times
        // Checkpoint timing for gap calculations
        checkpointTimes: {},
      };

      // AI cars
      const aiCars = [];

      // Team system with 6 attributes (1-20 scale, 60 total points per team)
      const aiTeams = [
        {
          name: "Emerald Isle Racing",
          color: "#228B22",
          country: "Ireland",
          founded: 2018,
          championships: 2,
          wins: 15,
          attributes: {
            speed: 12,
            acceleration: 10,
            handling: 14,
            braking: 12,
            reliability: 7,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Dragon Force Motorsport",
          color: "#DC143C",
          country: "Wales",
          founded: 2016,
          championships: 1,
          wins: 8,
          attributes: {
            speed: 14,
            acceleration: 16,
            handling: 8,
            braking: 9,
            reliability: 8,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Highland Racing Team",
          color: "#003DA5",
          country: "Scotland",
          founded: 2020,
          championships: 0,
          wins: 3,
          attributes: {
            speed: 8,
            acceleration: 9,
            handling: 16,
            braking: 13,
            reliability: 9,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Britannia Motors",
          color: "#191970",
          country: "England",
          founded: 2015,
          championships: 3,
          wins: 28,
          attributes: {
            speed: 18,
            acceleration: 12,
            handling: 8,
            braking: 11,
            reliability: 6,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Tricolore Racing",
          color: "#0055A4",
          country: "France",
          founded: 2017,
          championships: 1,
          wins: 12,
          attributes: {
            speed: 11,
            acceleration: 11,
            handling: 12,
            braking: 12,
            reliability: 9,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Kaiser Motorsport",
          color: "#FF0000",
          country: "Germany",
          founded: 2014,
          championships: 4,
          wins: 35,
          attributes: {
            speed: 13,
            acceleration: 13,
            handling: 7,
            braking: 16,
            reliability: 6,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Iberian Speed",
          color: "#C60B1E",
          country: "Spain",
          founded: 2019,
          championships: 0,
          wins: 5,
          attributes: {
            speed: 15,
            acceleration: 12,
            handling: 10,
            braking: 8,
            reliability: 10,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Veloce Italia",
          color: "#009246",
          country: "Italy",
          founded: 2013,
          championships: 2,
          wins: 18,
          attributes: {
            speed: 16,
            acceleration: 18,
            handling: 9,
            braking: 8,
            reliability: 4,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Adriatic Racing",
          color: "#FF6B00",
          country: "Croatia",
          founded: 2021,
          championships: 0,
          wins: 2,
          attributes: {
            speed: 10,
            acceleration: 11,
            handling: 11,
            braking: 11,
            reliability: 12,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Liberty Racing",
          color: "#002868",
          country: "USA",
          founded: 2012,
          championships: 1,
          wins: 9,
          attributes: {
            speed: 17,
            acceleration: 14,
            handling: 6,
            braking: 8,
            reliability: 10,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Rising Sun Motors",
          color: "#BC002D",
          country: "Japan",
          founded: 2016,
          championships: 0,
          wins: 6,
          attributes: {
            speed: 11,
            acceleration: 12,
            handling: 14,
            braking: 13,
            reliability: 5,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Celestial Motors",
          color: "#DE2910",
          country: "China",
          founded: 2018,
          championships: 0,
          wins: 4,
          attributes: {
            speed: 16,
            acceleration: 10,
            handling: 8,
            braking: 11,
            reliability: 10,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Maharaja Motors",
          color: "#FF9933",
          country: "India",
          founded: 2020,
          championships: 0,
          wins: 1,
          attributes: {
            speed: 9,
            acceleration: 10,
            handling: 10,
            braking: 9,
            reliability: 17,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Samba Racing Team",
          color: "#009739",
          country: "Brazil",
          founded: 2011,
          championships: 2,
          wins: 22,
          attributes: {
            speed: 12,
            acceleration: 19,
            handling: 13,
            braking: 7,
            reliability: 4,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Velocidad Venezuela",
          color: "#FFCC00",
          country: "Venezuela",
          founded: 2021,
          championships: 0,
          wins: 1,
          attributes: {
            speed: 7,
            acceleration: 9,
            handling: 13,
            braking: 14,
            reliability: 12,
            tireManagement: 5,
          }, // Total: 60
        },
        {
          name: "Regina Curse",
          color: "#FF69B4",
          country: "Romania",
          founded: 2022,
          championships: 0,
          wins: 0,
          attributes: {
            speed: 9,
            acceleration: 8,
            handling: 10,
            braking: 12,
            reliability: 16,
            tireManagement: 5,
          }, // Total: 60
        },
      ];

      // Visual effects
      const tireMarks = [];
      const sparkles = [];
      const flames = [];
      const rainDrops = [];
      const lightningBolts = [];
      let lastLightningTime = 0;
      
      // Weather effects configuration
      const weatherEffects = {
        clear: {
          visibility: 1.0,
          gripMultiplier: 1.0,
          particles: false
        },
        rain: {
          visibility: 0.8,
          gripMultiplier: 0.7,
          particles: true,
          particleCount: 100,
          particleSpeed: 8
        },
        storm: {
          visibility: 0.5,
          gripMultiplier: 0.4,
          particles: true,
          particleCount: 200,
          particleSpeed: 12
        }
      };
      
      // Initialize rain particles
      function initializeRainParticles() {
        rainDrops.length = 0;
        if (!weatherEffects[gameWeather].particles) return;
        
        const config = weatherEffects[gameWeather];
        // Create particles across a much larger world area (not just screen)
        const worldSize = 3000; // Cover the entire track area
        
        for (let i = 0; i < config.particleCount; i++) {
          rainDrops.push({
            x: Math.random() * worldSize,
            y: Math.random() * worldSize, 
            speed: config.particleSpeed + Math.random() * 4,
            length: 10 + Math.random() * 10,
            angle: Math.PI / 6, // 30 degree angle
            worldBased: true // Flag to indicate this uses world coordinates
          });
        }
      }
      
      // Update rain particles
      function updateRainParticles() {
        if (!weatherEffects[gameWeather].particles) return;
        
        const config = weatherEffects[gameWeather];
        const worldSize = 3000;
        
        rainDrops.forEach(drop => {
          drop.x += Math.cos(drop.angle) * drop.speed;
          drop.y += Math.sin(drop.angle) * drop.speed;
          
          // Reset particles that go off the world area
          if (drop.x > worldSize || drop.y > worldSize || drop.x < -100 || drop.y < -100) {
            drop.x = Math.random() * worldSize;
            drop.y = Math.random() * worldSize;
          }
        });
        
        // Update lightning for storm weather
        if (gameWeather === 'storm') {
          updateLightning();
        }
      }
      
      // Lightning system for storms
      function updateLightning() {
        const currentTime = Date.now();
        
        // Create lightning bolts every 6 seconds
        if (currentTime - lastLightningTime > 6000) {
          createLightningBolt();
          lastLightningTime = currentTime;
        }
        
        // Update existing lightning bolts (fade them out)
        for (let i = lightningBolts.length - 1; i >= 0; i--) {
          lightningBolts[i].life--;
          if (lightningBolts[i].life <= 0) {
            lightningBolts.splice(i, 1);
          }
        }
      }
      
      function createLightningBolt() {
        // Create lightning bolt in a random location near the visible area
        const boltX = camera.x + Math.random() * canvas.width;
        const boltY = camera.y + Math.random() * canvas.height;
        
        lightningBolts.push({
          x: boltX,
          y: boltY,
          life: 8, // Frames to display
          maxLife: 8,
          branches: generateLightningBranches(boltX, boltY)
        });
      }
      
      function generateLightningBranches(startX, startY) {
        const branches = [];
        const mainBranchLength = 200 + Math.random() * 300;
        
        // Main lightning bolt
        let currentX = startX;
        let currentY = startY;
        const segments = 8 + Math.floor(Math.random() * 6);
        
        for (let i = 0; i < segments; i++) {
          const segmentLength = mainBranchLength / segments;
          const angle = -Math.PI/2 + (Math.random() - 0.5) * 0.8; // Generally downward
          const nextX = currentX + Math.cos(angle) * segmentLength;
          const nextY = currentY + Math.sin(angle) * segmentLength;
          
          branches.push({
            x1: currentX,
            y1: currentY,
            x2: nextX,
            y2: nextY,
            thickness: 3 + Math.random() * 2
          });
          
          // Add smaller side branches occasionally
          if (Math.random() < 0.4) {
            const branchAngle = angle + (Math.random() - 0.5) * 1.5;
            const branchLength = segmentLength * (0.3 + Math.random() * 0.4);
            branches.push({
              x1: currentX,
              y1: currentY,
              x2: currentX + Math.cos(branchAngle) * branchLength,
              y2: currentY + Math.sin(branchAngle) * branchLength,
              thickness: 1 + Math.random() * 1
            });
          }
          
          currentX = nextX;
          currentY = nextY;
        }
        
        return branches;
      }
      
      // Render weather effects
      function renderWeatherEffects() {
        const config = weatherEffects[gameWeather];
        
        // Draw rain particles in world coordinates
        if (config.particles && rainDrops.length > 0) {
          ctx.save();
          ctx.strokeStyle = gameWeather === 'storm' ? 'rgba(200, 200, 255, 0.6)' : 'rgba(150, 150, 200, 0.4)';
          ctx.lineWidth = gameWeather === 'storm' ? 2 : 1;
          
          rainDrops.forEach(drop => {
            // Only draw particles that are visible on screen
            if (drop.x >= camera.x - 100 && drop.x <= camera.x + canvas.width + 100 &&
                drop.y >= camera.y - 100 && drop.y <= camera.y + canvas.height + 100) {
              ctx.beginPath();
              ctx.moveTo(drop.x, drop.y);
              ctx.lineTo(
                drop.x + Math.cos(drop.angle) * drop.length,
                drop.y + Math.sin(drop.angle) * drop.length
              );
              ctx.stroke();
            }
          });
          ctx.restore();
        }
        
        // Draw lightning bolts for storm weather
        if (gameWeather === 'storm' && lightningBolts.length > 0) {
          ctx.save();
          
          lightningBolts.forEach(bolt => {
            const alpha = bolt.life / bolt.maxLife;
            
            bolt.branches.forEach(branch => {
              // Main bolt glow
              ctx.shadowColor = `rgba(255, 255, 255, ${alpha * 0.8})`;
              ctx.shadowBlur = 15;
              ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
              ctx.lineWidth = branch.thickness;
              
              ctx.beginPath();
              ctx.moveTo(branch.x1, branch.y1);
              ctx.lineTo(branch.x2, branch.y2);
              ctx.stroke();
              
              // Inner bright core
              ctx.shadowBlur = 5;
              ctx.strokeStyle = `rgba(200, 200, 255, ${alpha})`;
              ctx.lineWidth = branch.thickness * 0.3;
              
              ctx.beginPath();
              ctx.moveTo(branch.x1, branch.y1);
              ctx.lineTo(branch.x2, branch.y2);
              ctx.stroke();
            });
          });
          
          ctx.shadowColor = 'transparent';
          ctx.shadowBlur = 0;
          ctx.restore();
        }
        
        // Note: Canvas dimming removed - using grass color changes instead for better coverage
      }

      // Add tire mark
      function addTireMark(x, y, angle) {
        tireMarks.push({
          x: x,
          y: y,
          angle: angle,
          alpha: 0.3,
          age: 0,
        });

        // Limit tire marks for performance
        if (tireMarks.length > 100) {
          tireMarks.shift();
        }
      }

      // Add collision sparkle
      function addSparkle(x, y) {
        for (let i = 0; i < 5; i++) {
          sparkles.push({
            x: x + (Math.random() - 0.5) * 10,
            y: y + (Math.random() - 0.5) * 10,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            life: 20,
            maxLife: 20,
          });
        }
      }

      // Add flame effect for nitro
      function addFlame(x, y, angle, intensity = 1) {
        for (let i = 0; i < 3 * intensity; i++) {
          flames.push({
            x: x,
            y: y,
            vx: Math.cos(angle + Math.PI) * (2 + Math.random() * 3) * intensity,
            vy: Math.sin(angle + Math.PI) * (2 + Math.random() * 3) * intensity,
            life: 15,
            maxLife: 15,
            size: 2 + Math.random() * 3,
          });
        }
      }

      // AI Behavior Engine - Creates unique personalities for each AI car
      class AIBehavior {
        constructor(car) {
          this.car = car;
          this.state = "racing"; // Current AI state: racing, overtaking, defending, avoiding
          this.targetLine = "optimal"; // Racing line preference: optimal, inside, outside

          // AI personality traits - each trait affects different aspects of driving behavior
          // Values are carefully balanced to create realistic but varied AI opponents
          this.aggressiveness = Math.random() * 0.4 + 0.4; // 0.4-0.8: Controls overtaking frequency and risk-taking
          this.cornering_skill = Math.random() * 0.3 + 0.6; // 0.6-0.9: Affects corner entry speed and line optimization
          this.overtaking_ability = Math.random() * 0.4 + 0.4; // 0.4-0.8: Influences overtaking success rate
          this.defending_skill = Math.random() * 0.4 + 0.4; // 0.4-0.8: Determines defensive maneuver effectiveness
          this.racecraft = Math.random() * 0.3 + 0.6; // 0.6-0.9: Overall racing intelligence and decision making
          this.awareness = Math.random() * 0.3 + 0.6; // 0.6-0.9: Detection range for other cars and hazards
          this.smoothness = Math.random() * 0.4 + 0.5; // 0.5-0.9: Reduces erratic movements and mistakes
          this.pace_consistency = Math.random() * 0.2 + 0.7; // 0.7-0.9: Maintains consistent lap times

          // Driving style preferences - affects racing line and positioning
          this.preferred_line_offset = (Math.random() - 0.5) * 20; // -10 to +10: Racing line bias (inside/outside)
          this.corner_entry_preference = Math.random() * 0.6 + 0.2; // 0.2-0.8: Early vs late braking preference
          this.braking_style = Math.random() * 0.6 + 0.2; // 0.2-0.8: Conservative vs aggressive braking
          this.throttle_style = Math.random() * 0.6 + 0.2; // 0.2-0.8: Smooth vs aggressive acceleration

          // Dynamic behavior state variables
          this.current_line_offset = this.preferred_line_offset; // Current racing line deviation
          this.overtake_cooldown = 0; // Prevents constant overtaking attempts
          this.defend_cooldown = 0; // Prevents constant defensive moves
          this.line_change_timer = Math.random() * 200; // Controls racing line variations
          this.mistake_chance = (1 - this.smoothness) * 0.003; // Probability of making driving errors
          this.last_mistake_time = 0; // Tracks when last mistake occurred

          // Tactical awareness and decision making
          this.lookAheadDistance = 60 + this.awareness * 80; // 60-140: How far ahead AI can "see"
          this.reaction_time = Math.floor((1 - this.awareness) * 20); // 0-20 frames: Simulated human reaction delay
          this.decision_buffer = []; // Stores recent racing situations for delayed reactions
        }

        // Main AI update function - called every frame to determine AI behavior
        update(allCars, track) {
          // Decrement action cooldowns to prevent unrealistic constant maneuvers
          if (this.overtake_cooldown > 0) this.overtake_cooldown--;
          if (this.defend_cooldown > 0) this.defend_cooldown--;

          // Simulate human-like reaction time by buffering decisions
          this.decision_buffer.push({ cars: [...allCars], time: Date.now() });
          if (this.decision_buffer.length > this.reaction_time) {
            this.decision_buffer.shift();
          }
          const delayed_situation = this.decision_buffer[0] || {
            cars: allCars,
          };

          // Dynamic line adjustment based on personality
          this.line_change_timer--;
          if (this.line_change_timer <= 0) {
            const line_variation =
              (Math.random() - 0.5) * 20 * (1 - this.smoothness);
            this.current_line_offset += line_variation;
            this.current_line_offset = Math.max(
              -30,
              Math.min(30, this.current_line_offset)
            );
            this.line_change_timer = 100 + Math.random() * 300;
          }

          // Occasional mistakes based on smoothness and difficulty settings
          if (
            difficultySettings[gameDifficulty].aiMistakesEnabled &&
            Math.random() < this.mistake_chance * difficultySettings[gameDifficulty].aiMistakeFrequency &&
            Date.now() - this.last_mistake_time > 2000
          ) {
            this.makeMistake();
            this.last_mistake_time = Date.now();
          }

          // Analyze racing situation with comprehensive awareness
          const nearby_cars = this.findNearbyCars(delayed_situation.cars);
          const overtake_opportunity = this.assessOvertakeOpportunity(
            nearby_cars,
            track
          );
          const defensive_needed = this.assessDefensiveNeed(nearby_cars);
          const traffic_ahead = this.detectTrafficAhead(nearby_cars);

          // Advanced state machine for decision making
          if (
            overtake_opportunity &&
            this.overtake_cooldown === 0 &&
            this.overtaking_ability > 0.5
          ) {
            this.state = "overtaking";
            this.overtake_cooldown = Math.floor(180 / this.aggressiveness); // More aggressive = shorter cooldown
          } else if (
            defensive_needed &&
            this.defend_cooldown === 0 &&
            this.defending_skill > 0.4
          ) {
            this.state = "defending";
            this.defend_cooldown = Math.floor(120 / this.defending_skill);
          } else if (traffic_ahead && this.awareness > 0.6) {
            this.state = "avoiding";
          } else {
            this.state = "racing";
          }

          return this.calculateTargetPath(track, nearby_cars);
        }

        makeMistake() {
          // Temporary line offset for mistakes
          const mistake_magnitude = 15 + Math.random() * 25;
          this.current_line_offset += (Math.random() - 0.5) * mistake_magnitude;
          this.current_line_offset = Math.max(
            -40,
            Math.min(40, this.current_line_offset)
          );

          // Reduce speed temporarily
          this.car.velocity.x *= 0.85;
          this.car.velocity.y *= 0.85;
        }

        findNearbyCars(allCars) {
          const nearby = [];
          const detection_range = this.lookAheadDistance;

          allCars.forEach((other) => {
            if (other === this.car) return;

            const dx = other.x - this.car.x;
            const dy = other.y - this.car.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < detection_range) {
              const angle_to_other = Math.atan2(dy, dx);
              const relative_angle = angle_to_other - this.car.angle;
              let normalized_angle = relative_angle;
              while (normalized_angle > Math.PI)
                normalized_angle -= 2 * Math.PI;
              while (normalized_angle < -Math.PI)
                normalized_angle += 2 * Math.PI;

              nearby.push({
                car: other,
                distance: distance,
                relative_angle: normalized_angle,
                is_ahead: Math.abs(normalized_angle) < Math.PI / 3,
                is_behind: Math.abs(normalized_angle) > (2 * Math.PI) / 3,
                is_alongside:
                  Math.abs(normalized_angle) >= Math.PI / 3 &&
                  Math.abs(normalized_angle) <= (2 * Math.PI) / 3,
              });
            }
          });

          return nearby;
        }

        assessOvertakeOpportunity(nearby_cars, track) {
          const cars_ahead = nearby_cars.filter(
            (car) => car.is_ahead && car.distance < 80
          );
          if (cars_ahead.length === 0) return false;

          const target_car = cars_ahead.reduce((closest, car) =>
            car.distance < closest.distance ? car : closest
          );

          // Check if target is significantly slower
          const speed_advantage = this.car.speed - target_car.car.speed;
          const speed_threshold = 0.5 * this.aggressiveness;

          // Check if there's space to overtake
          const space_left = !nearby_cars.some(
            (car) => car.relative_angle > 0 && car.distance < 60
          );
          const space_right = !nearby_cars.some(
            (car) => car.relative_angle < 0 && car.distance < 60
          );

          return (
            speed_advantage > speed_threshold && (space_left || space_right)
          );
        }

        assessDefensiveNeed(nearby_cars) {
          const attackers = nearby_cars.filter(
            (car) =>
              car.is_behind &&
              car.distance < 50 &&
              car.car.speed > this.car.speed * 1.05
          );

          return attackers.length > 0 && this.defending_skill > 0.5;
        }

        detectTrafficAhead(nearby_cars) {
          return nearby_cars.some(
            (car) =>
              car.is_ahead &&
              car.distance < 40 &&
              Math.abs(car.relative_angle) < Math.PI / 6
          );
        }

        calculateTargetPath(track, nearby_cars) {
          let target_point = this.getOptimalRacingLine(track);

          // Apply state-specific modifications
          switch (this.state) {
            case "overtaking":
              target_point = this.calculateOvertakingLine(
                target_point,
                nearby_cars
              );
              break;
            case "defending":
              target_point = this.calculateDefensiveLine(
                target_point,
                nearby_cars
              );
              break;
            case "avoiding":
              target_point = this.calculateAvoidanceLine(
                target_point,
                nearby_cars
              );
              break;
          }

          return target_point;
        }

        getOptimalRacingLine(track) {
          const current_wp = track.waypoints[this.car.targetWaypoint];
          const next_wp =
            track.waypoints[
              (this.car.targetWaypoint + 1) % track.waypoints.length
            ];
          const lookahead_wp =
            track.waypoints[
              (this.car.targetWaypoint + 2) % track.waypoints.length
            ];

          // Blend waypoints for smoother path based on cornering skill
          const blend_factor = 0.3 + this.cornering_skill * 0.4;
          let target = {
            x: current_wp.x * (1 - blend_factor) + next_wp.x * blend_factor,
            y: current_wp.y * (1 - blend_factor) + next_wp.y * blend_factor,
          };

          // Apply racing line offset based on personality and current state
          const track_direction = Math.atan2(
            next_wp.y - current_wp.y,
            next_wp.x - current_wp.x
          );
          const perpendicular = track_direction + Math.PI / 2;

          // Dynamic line offset based on corner type and preference
          const corner_radius = this.calculateCornerRadius(
            current_wp,
            next_wp,
            lookahead_wp
          );
          let line_offset = this.current_line_offset;

          // Adjust for corner entry/exit preferences
          if (corner_radius < 200) {
            // Tight corner
            line_offset *= 0.7 + this.cornering_skill * 0.3;

            // Late brakers take wider line
            if (this.corner_entry_preference > 0.7) {
              line_offset += 10;
            }
          }

          target.x += Math.cos(perpendicular) * line_offset;
          target.y += Math.sin(perpendicular) * line_offset;

          return target;
        }

        calculateCornerRadius(wp1, wp2, wp3) {
          const dx1 = wp2.x - wp1.x;
          const dy1 = wp2.y - wp1.y;
          const dx2 = wp3.x - wp2.x;
          const dy2 = wp3.y - wp2.y;

          const cross = dx1 * dy2 - dy1 * dx2;
          const dot = dx1 * dx2 + dy1 * dy2;

          if (Math.abs(cross) < 0.1) return 1000; // Straight line

          const angle = Math.atan2(cross, dot);
          return Math.abs(1 / Math.sin(angle / 2));
        }

        calculateOvertakingLine(base_target, nearby_cars) {
          const cars_ahead = nearby_cars.filter((car) => car.is_ahead);
          if (cars_ahead.length === 0) return base_target;

          const target_car = cars_ahead[0];

          // Choose overtaking side based on space and preference, and target car position
          const left_clear = !nearby_cars.some(
            (car) => car.relative_angle > 0 && car.distance < 70
          );
          const right_clear = !nearby_cars.some(
            (car) => car.relative_angle < 0 && car.distance < 70
          );

          let overtake_direction = 0;
          if (left_clear && right_clear) {
            // Choose based on target car's relative position and racing line preference
            const target_relative_angle =
              Math.atan2(
                target_car.car.y - this.car.y,
                target_car.car.x - this.car.x
              ) - this.car.angle;

            // Go to the opposite side of where the target car is positioned
            overtake_direction = target_relative_angle > 0 ? -1 : 1;

            // Also consider racing line preference as secondary factor
            if (Math.abs(target_relative_angle) < 0.2) {
              overtake_direction = this.preferred_line_offset > 0 ? 1 : -1;
            }
          } else if (left_clear) {
            overtake_direction = 1;
          } else if (right_clear) {
            overtake_direction = -1;
          }

          // Adjust overtaking aggression based on target car's speed
          const speed_difference = this.car.speed - target_car.car.speed;
          const overtake_magnitude =
            25 + this.aggressiveness * 15 + speed_difference * 5;
          const direction_angle = this.car.angle + Math.PI / 2;

          return {
            x:
              base_target.x +
              Math.cos(direction_angle) *
                overtake_direction *
                overtake_magnitude,
            y:
              base_target.y +
              Math.sin(direction_angle) *
                overtake_direction *
                overtake_magnitude,
          };
        }

        calculateDefensiveLine(base_target, nearby_cars) {
          const attackers = nearby_cars.filter(
            (car) => car.is_behind && car.car.speed > this.car.speed
          );
          if (attackers.length === 0) return base_target;

          const attacker = attackers[0];
          const block_direction = attacker.relative_angle > 0 ? 1 : -1;
          const defensive_magnitude = 15 + this.defending_skill * 10;
          const direction_angle = this.car.angle + Math.PI / 2;

          return {
            x:
              base_target.x +
              Math.cos(direction_angle) * block_direction * defensive_magnitude,
            y:
              base_target.y +
              Math.sin(direction_angle) * block_direction * defensive_magnitude,
          };
        }

        calculateAvoidanceLine(base_target, nearby_cars) {
          let avoidance_x = 0;
          let avoidance_y = 0;

          nearby_cars.forEach((car) => {
            if (car.distance < 50) {
              const avoidance_strength =
                ((50 - car.distance) / 50) * this.awareness;
              const dx = this.car.x - car.car.x;
              const dy = this.car.y - car.car.y;
              const length = Math.sqrt(dx * dx + dy * dy);

              if (length > 0) {
                avoidance_x += (dx / length) * avoidance_strength * 20;
                avoidance_y += (dy / length) * avoidance_strength * 20;
              }
            }
          });

          return {
            x: base_target.x + avoidance_x,
            y: base_target.y + avoidance_y,
          };
        }
      }

      // Create AI cars with advanced behavior
      function createAICars() {
        aiCars.length = 0;

        // Map selectedTeam (key) to actual team name
        const teamMapping = {
          emerald_isle: "Emerald Isle Racing",
          dragon_force: "Dragon Force Motorsport",
          highland_racing: "Highland Racing Team",
          britannia_motors: "Britannia Motors",
          tricolore_racing: "Tricolore Racing",
          kaiser_motorsport: "Kaiser Motorsport",
          iberian_speed: "Iberian Speed",
          veloce_italia: "Veloce Italia",
          adriatic_racing: "Adriatic Racing",
          liberty_racing: "Liberty Racing",
          rising_sun: "Rising Sun Motors",
          celestial_motors: "Celestial Motors",
          maharaja_motors: "Maharaja Motors",
          samba_racing: "Samba Racing Team",
          velocidad_venezuela: "Velocidad Venezuela",
          regina_curse: "Regina Curse",
        };

        const playerTeamName = teamMapping[selectedTeam];

        // Filter out the player's selected team from AI teams
        const availableTeams = aiTeams.filter(
          (team) => team.name !== playerTeamName
        );
        
        // Get the difficulty multiplier from current settings
        const difficultyMultiplier = difficultySettings[gameDifficulty].aiAttributeMultiplier;

        for (let i = 0; i < availableTeams.length; i++) {
          // Use all 15 remaining teams
          const team = availableTeams[i];
          // Create proper F1-style grid formation with 2 cars per row
          // Player starts at front (row 0), AI cars start behind in rows 1, 2, 3, etc.
          const gridRow = Math.floor(i / 2) + 1; // Start from row 1 (player is row 0)
          const gridSide = i % 2;

          // Stagger the grid positions slightly for more realistic racing start
          const staggerOffset = gridSide === 0 ? -3 : 3; // Left cars slightly ahead

          // Calculate team multipliers from attributes (scale: 1-20, normalized to 1.0-2.0 for better performance)
          // Apply difficulty multiplier to AI car attributes
          const speedMultiplier = (1.0 + (team.attributes.speed / 20) * 1.0) * difficultyMultiplier;
          const accelMultiplier = (1.0 + (team.attributes.acceleration / 20) * 1.0) * difficultyMultiplier;
          const handlingMultiplier = (1.0 + (team.attributes.handling / 20) * 1.0) * difficultyMultiplier;
          const brakingMultiplier = (1.0 + (team.attributes.braking / 20) * 1.0) * difficultyMultiplier;
          const reliabilityMultiplier = (0.8 + (team.attributes.reliability / 20) * 0.4) * difficultyMultiplier;
          const tireMultiplier = (0.8 + (team.attributes.tireManagement / 20) * 0.4) * difficultyMultiplier;

          const aiCar = {
            x: 1000 + (gridSide === 0 ? -30 : 30), // Grid spacing left/right of centerline
            y: 1350 + gridRow * 35 + staggerOffset, // Position BEHIND start/finish line (at y=1300)
            angle: -Math.PI / 2, // Point upward initially
            velocity: { x: 0, y: -0.1 }, // Small initial velocity pointing upward (negative Y)
            speed: 0.1, // Small initial speed
            // Core performance stats affected by team attributes
            maxSpeed: (7.8 + Math.random() * 0.6) * speedMultiplier,
            acceleration: (0.2 + Math.random() * 0.04) * accelMultiplier,
            // Braking system using team-specific multiplier
            friction: (0.94 + Math.random() * 0.02) * brakingMultiplier,
            brakingPower: (0.12 + Math.random() * 0.03) * brakingMultiplier,
            turnSpeed: (0.055 + Math.random() * 0.015) * handlingMultiplier,
            size: 18,
            color: team.color,
            name: team.name,
            // Team attributes for gameplay effects
            teamAttributes: team.attributes,
            // Race state
            currentCheckpoint: 1,
            checkpointsHit: [true, false, false],
            lapProgress: 0,
            lapsCompleted: 0,
            targetWaypoint: 1,
            racePosition: i + 2,
            // Damage and wear system (reset to zero for new race)
            damage: {
              speed: 0, // 0-100, reduces maxSpeed
              acceleration: 0, // 0-100, reduces acceleration
              handling: 0, // 0-100, reduces turnSpeed
              braking: 0, // 0-100, reduces braking
              visible: false,
            },
            // Tire management (reset to zero for new race)
            tireWear: 0, // 0-100, affected by tireManagement
            tireWearRate: 0.5 / tireMultiplier, // Slower wear = better tire management
            reliabilityFactor: reliabilityMultiplier, // Affects chance of mechanical failures
            lastCollisionTime: 0,
            // AI Nitro system
            nitro: 100,
            maxNitro: 100,
            usingNitro: false,
            nitroRegenRate: 0.25,
            nitroStrategy: Math.random() * 0.4 + 0.3,
            lastNitroUse: 0,
            // Physics properties
            wheelBase: 16,
            steerAngle: 0,
            angularVelocity: 0,
            weightTransfer: 0,
            // Lap time tracking for accurate gap calculation
            lapTimes: [], // Array of completed lap times in seconds
            currentLapStartTime: 0, // When current lap started
            totalRaceTime: 0, // Sum of all completed lap times
            // Checkpoint timing for gap calculations
            checkpointTimes: {},
          };

          // Add AI behavior engine
          aiCar.behavior = new AIBehavior(aiCar);
          
          // Apply difficulty-specific adjustments to behavior
          if (gameDifficulty === "hard") {
            // Hard: Perfect AI - Higher awareness and consistency
            aiCar.behavior.awareness = Math.min(1.0, aiCar.behavior.awareness * 1.3);
            aiCar.behavior.smoothness = Math.min(1.0, aiCar.behavior.smoothness * 1.3);
            aiCar.behavior.pace_consistency = Math.min(1.0, aiCar.behavior.pace_consistency * 1.2);
            aiCar.behavior.mistake_chance = 0; // No mistakes on hard
          } else if (gameDifficulty === "easy") {
            // Easy: More forgiving AI - Lower aggression and racing skill
            aiCar.behavior.aggressiveness *= 0.7;
            aiCar.behavior.cornering_skill *= 0.8;
            aiCar.behavior.mistake_chance *= 1.5; // More mistakes on easy
            aiCar.behavior.reaction_time *= 1.3; // Slower reactions
          }
          
          aiCars.push(aiCar);
        }
      }

      // Collision Detection and Response
      /**
       * Collision Detection System with Race Start Protection
       *
       * Implements sophisticated collision detection that protects cars during race start
       * to prevent pile-ups while enabling realistic contact during racing.
       *
       * Features:
       * - "Ghost mode" protection for cars during race start (first 15 seconds)
       * - Pairwise collision detection between all cars
       * - Checkpoint-based collision eligibility (must pass 2 checkpoints to collide)
       * - Distance-based collision detection with car size consideration
       *
       * Ghost Mode Criteria:
       * - Car must be on first lap (lapsCompleted === 0)
       * - Car hasn't passed minimum checkpoints (protects grid start)
       * - Race time is within protection window (15 seconds)
       */
      function handleCarCollisions() {
        // Skip collision handling entirely if collisions are disabled in difficulty settings
        if (!difficultySettings[gameDifficulty].collisionsEnabled) {
          return;
        }
        
        const allCars = [player, ...aiCars];

        // Ghosting system prevents collisions during race start when cars are close together
        const raceTime = gameRunning ? (Date.now() - raceStartTime) / 1000 : 0;
        const minCheckpointsForCollisions = 2; // Cars must pass 2 checkpoints before collisions enabled
        const maxGhostingTime = 15; // Maximum duration of collision protection (seconds)

        // Check every pair of cars for potential collisions
        for (let i = 0; i < allCars.length; i++) {
          for (let j = i + 1; j < allCars.length; j++) {
            const car1 = allCars[i];
            const car2 = allCars[j];

            // Determine if each car is in "ghost mode" (collision-immune)
            const car1Ghosted =
              car1.lapsCompleted === 0 && // Still on first lap
              car1.currentCheckpoint <= minCheckpointsForCollisions && // Haven't passed enough checkpoints
              raceTime <= maxGhostingTime; // Within time limit
            const car2Ghosted =
              car2.lapsCompleted === 0 &&
              car2.currentCheckpoint <= minCheckpointsForCollisions &&
              raceTime <= maxGhostingTime;

            // Skip collision if either car is still ghosted
            if (car1Ghosted || car2Ghosted) {
              continue;
            }

            const dx = car2.x - car1.x;
            const dy = car2.y - car1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = (car1.size + car2.size) / 2;

            if (distance < minDistance) {
              handleCollision(car1, car2, dx, dy, distance);
            }
          }
        }
      }

      function handleCollision(car1, car2, dx, dy, distance) {
        // Calculate collision severity based on relative speeds
        const relativeVelX = car2.velocity.x - car1.velocity.x;
        const relativeVelY = car2.velocity.y - car1.velocity.y;
        const relativeSpeed = Math.sqrt(
          relativeVelX * relativeVelX + relativeVelY * relativeVelY
        );

        // Only process if cars are approaching each other
        const approaching = dx * relativeVelX + dy * relativeVelY < 0;
        if (!approaching) return;

        // Collision response
        const overlap = (car1.size + car2.size) / 2 - distance;
        const separationForce = overlap * 0.5;

        const normalX = dx / distance;
        const normalY = dy / distance;

        // Separate cars
        car1.x -= normalX * separationForce;
        car1.y -= normalY * separationForce;
        car2.x += normalX * separationForce;
        car2.y += normalY * separationForce;

        // Apply collision damage based on collision severity - reduced sensitivity
        const damageAmount = Math.min(8, relativeSpeed * 1.2);
        applyCollisionDamage(car1, damageAmount);
        applyCollisionDamage(car2, damageAmount);

        // Velocity exchange (simplified)
        const dampening = 0.3;
        const velExchangeX = relativeVelX * dampening;
        const velExchangeY = relativeVelY * dampening;

        car1.velocity.x += velExchangeX * 0.5;
        car1.velocity.y += velExchangeY * 0.5;
        car2.velocity.x -= velExchangeX * 0.5;
        car2.velocity.y -= velExchangeY * 0.5;

        // Visual effects
        const collisionX = (car1.x + car2.x) / 2;
        const collisionY = (car1.y + car2.y) / 2;
        addSparkle(collisionX, collisionY);

        // Set collision timestamps
        car1.lastCollisionTime = Date.now();
        car2.lastCollisionTime = Date.now();
      }

      function applyCollisionDamage(car, amount) {
        // Apply damage to random components based on reliability
        const reliabilityFactor = car.reliabilityFactor || 1.0;
        const actualDamage = amount / reliabilityFactor;

        // Distribute damage across different systems
        const damageTypes = ["speed", "acceleration", "handling", "braking"];
        const selectedDamage =
          damageTypes[Math.floor(Math.random() * damageTypes.length)];

        car.damage[selectedDamage] = Math.min(
          100,
          car.damage[selectedDamage] + actualDamage
        );
        car.damage.visible = true;

        // Apply damage effects immediately
        applyDamageEffects(car);
      }

      function applyDamageEffects(car) {
        // Reduce performance based on damage
        const speedReduction = 1 - car.damage.speed / 200; // Max 50% reduction
        const accelReduction = 1 - car.damage.acceleration / 200;
        const handlingReduction = 1 - car.damage.handling / 200;
        const brakingReduction = 1 - car.damage.braking / 200;

        if (car === player) {
          // Apply to player car
          car.maxSpeed = car.baseMaxSpeed * speedReduction;
          car.acceleration = car.baseAcceleration * accelReduction;
          car.turnSpeed = car.baseTurnSpeed * handlingReduction;
          car.friction = Math.max(0.8, car.baseFriction * brakingReduction);
        } else {
          // Apply to AI cars (store original values if not stored)
          if (!car.originalMaxSpeed) {
            car.originalMaxSpeed = car.maxSpeed;
            car.originalAcceleration = car.acceleration;
            car.originalTurnSpeed = car.turnSpeed;
            car.originalFriction = car.friction;
          }

          car.maxSpeed = car.originalMaxSpeed * speedReduction;
          car.acceleration = car.originalAcceleration * accelReduction;
          car.turnSpeed = car.originalTurnSpeed * handlingReduction;
          car.friction = Math.max(0.8, car.originalFriction * brakingReduction);
        }
      }

      // Advanced grip and tire physics for realistic F1 handling
      function calculateAdvancedGrip(
        car,
        steerInput,
        throttleInput,
        brakingInput
      ) {
        const speed = Math.sqrt(
          car.velocity.x * car.velocity.x + car.velocity.y * car.velocity.y
        );
        const speedRatio = speed / car.maxSpeed;

        // Base grip from tire compound (F1 cars have excellent base grip)
        let frontGrip = 0.95;
        let rearGrip = 0.93; // Slightly less for realistic oversteer tendency

        // Speed-based grip reduction (aerodynamic load vs tire heating)
        const speedGripLoss = speedRatio * speedRatio * 0.15; // Much less aggressive
        frontGrip -= speedGripLoss;
        rearGrip -= speedGripLoss;

        // Steering input affects front tire grip
        const steerGripLoss = Math.abs(steerInput) * 0.1; // Reduced penalty
        frontGrip -= steerGripLoss;

        // Throttle affects rear tire grip
        const throttleGripLoss = Math.abs(throttleInput) * speedRatio * 0.08;
        rearGrip -= throttleGripLoss;

        // Braking affects both axles differently
        if (brakingInput > 0) {
          const brakeBalance = 0.6; // 60% front, 40% rear (typical F1)
          frontGrip -= brakingInput * brakeBalance * 0.15;
          rearGrip -= brakingInput * (1 - brakeBalance) * 0.12;
        }

        // Weight transfer effects - realistic F1 physics with asymmetric handling
        const lateralGs = Math.abs(car.angularVelocity) * speed;
        const weightTransferEffect = lateralGs * 0.1;

        // Weight transfers to outside wheels during cornering - affects grip distribution
        if (car.steerAngle > 0) {
          // Right turn - weight transfers to left side (outside wheels)
          // F1 cars typically have slightly different left/right characteristics
          frontGrip += weightTransferEffect * 0.45; // Right turns: slightly more front grip
          rearGrip += weightTransferEffect * 0.3; // More rear stability for right turns
          // Simulate inside wheel unloading
          frontGrip -= weightTransferEffect * 0.08; // Less front inside grip loss
          rearGrip -= weightTransferEffect * 0.04; // Minimal rear inside grip loss
        } else if (car.steerAngle < 0) {
          // Left turn - weight transfers to right side (outside wheels)
          // Asymmetric setup for more realistic handling characteristics
          frontGrip += weightTransferEffect * 0.4; // Left turns: standard front grip
          rearGrip += weightTransferEffect * 0.25; // Less rear grip for oversteer tendency
          // Different unloading characteristics for left turns
          frontGrip -= weightTransferEffect * 0.12; // More front inside grip loss
          rearGrip -= weightTransferEffect * 0.06; // Slightly more rear inside grip loss
        }

        // Ensure grip values stay within realistic bounds
        frontGrip = Math.max(0.3, Math.min(1.0, frontGrip));
        rearGrip = Math.max(0.25, Math.min(1.0, rearGrip));

        // Apply weather effects to grip
        const weatherGripMultiplier = weatherEffects[gameWeather].gripMultiplier;
        frontGrip *= weatherGripMultiplier;
        rearGrip *= weatherGripMultiplier;

        // Ensure final grip values stay within bounds after weather effects
        frontGrip = Math.max(0.1, Math.min(1.0, frontGrip));
        rearGrip = Math.max(0.1, Math.min(1.0, rearGrip));

        return { front: frontGrip, rear: rearGrip };
      }

      function updatePlayer() {
        const currentSpeed = calculateCurrentSpeed();
        const inputs = handlePlayerInputs();

        handleNitroSystem(inputs);
        handleSteering(inputs.steering, currentSpeed);
        handleAcceleration(inputs.acceleration);
        handleBraking(inputs.braking, currentSpeed);

        limitSpeed();
        updatePosition();
        updateTireWear(inputs, currentSpeed);
        applyFriction(currentSpeed);

        handleTrackCollision(player);
        updatePlayerSpeed();
        constrainToBounds();
        checkPlayerCheckpoints();
        
        // Record ghost data for time trial
        if (isTimeTrialMode && isRecordingGhost && gameRunning) {
          currentGhostRecording.push({
            x: player.x,
            y: player.y,
            angle: player.angle,
            timestamp: Date.now()
          });
        }
      }
      
      // Time Trial ghost management functions
      function updateTimeTrialGhosts() {
        if (!isTimeTrialMode) return;
        
        timeTrialGhosts.forEach(ghost => {
          ghost.update();
        });
      }
      
      function completeTimeTrialLap(lapTime) {
        if (!isTimeTrialMode) return;
        
        // Stop recording current ghost
        isRecordingGhost = false;
        
        // Create lap data object
        const lapData = {
          playerName: selectedTeam || "Player",
          teamName: getSelectedTeamName(),
          lapTime: lapTime,
          ghostData: [...currentGhostRecording],
          weather: gameWeather,
          difficulty: gameDifficulty,
          date: new Date().toISOString(),
          track: "Circuit Racer Track" // Add track name for future track support
        };
        
        // Add to time trial laps
        timeTrialLaps.push(lapData);
        
        // Update best lap if this is better
        if (!bestTimeTrialLap || lapTime < bestTimeTrialLap.lapTime) {
          bestTimeTrialLap = lapData;
        }
        
        // Show time trial complete screen
        showTimeTrialComplete(lapData);
      }
      
      function getSelectedTeamName() {
        const teamMapping = {
          emerald_isle: "Emerald Isle Racing",
          dragon_force: "Dragon Force Motorsport",
          highland_racing: "Highland Racing Team",
          britannia_motors: "Britannia Motors",
          tricolore_racing: "Tricolore Racing",
          kaiser_motorsport: "Kaiser Motorsport",
          iberian_speed: "Iberian Speed",
          veloce_italia: "Veloce Italia",
          adriatic_racing: "Adriatic Racing",
          liberty_racing: "Liberty Racing",
          rising_sun: "Rising Sun Motors",
          celestial_motors: "Celestial Motors",
          maharaja_motors: "Maharaja Motors",
          samba_racing: "Samba Racing Team",
          velocidad_venezuela: "Velocidad Venezuela",
          regina_curse: "Regina Curse",
        };
        return teamMapping[selectedTeam] || "Unknown Team";
      }
      
      // Import/Export functions for time trial data
      function exportTimeTrialLap(lapData) {
        const exportData = {
          version: "1.0",
          ...lapData
        };
        
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], {type: 'application/json'});
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `time-trial-${lapData.playerName}-${formatTime(lapData.lapTime)}.json`;
        link.click();
      }
      
      function importTimeTrialLap() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = function(e) {
          const file = e.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const lapData = JSON.parse(e.target.result);
              
              // Validate imported data
              if (!lapData.ghostData || !lapData.lapTime || !lapData.playerName) {
                alert('Invalid time trial file format!');
                return;
              }
              
              // Create ghost car from imported data
              const ghost = new GhostCar(
                lapData.ghostData,
                lapData.playerName,
                lapData.teamName,
                lapData.lapTime
              );
              
              timeTrialGhosts.push(ghost);
              
              alert(`Successfully imported ${lapData.playerName}'s lap: ${formatTime(lapData.lapTime)}`);
              updateTimeTrialGhostList();
              
            } catch (error) {
              alert('Error reading time trial file: ' + error.message);
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }
      
      function removeTimeTrialGhost(index) {
        if (index >= 0 && index < timeTrialGhosts.length) {
          timeTrialGhosts.splice(index, 1);
          updateTimeTrialGhostList();
        }
      }
      
      function clearAllTimeTrialGhosts() {
        timeTrialGhosts.length = 0;
        updateTimeTrialGhostList();
      }

      // GhostCar class for time trial mode
      class GhostCar {
        constructor(ghostData, playerName, lapTime) {
          this.ghostData = ghostData;
          this.playerName = playerName;
          this.lapTime = lapTime;
          this.currentFrame = 0;
          this.isActive = true;
          this.x = 0;
          this.y = 0;
          this.angle = 0;
          this.startTime = null;
        }

        reset() {
          this.currentFrame = 0;
          this.startTime = null;
          this.isActive = true;
        }

        update() {
          if (!this.isActive || !this.ghostData || this.ghostData.length === 0) return;

          if (!this.startTime && gameRunning) {
            this.startTime = Date.now();
          }

          if (this.startTime) {
            const elapsedTime = Date.now() - this.startTime;
            
            // Find the appropriate frame based on elapsed time
            let targetFrame = 0;
            for (let i = 0; i < this.ghostData.length; i++) {
              const frameTime = this.ghostData[i].timestamp - this.ghostData[0].timestamp;
              if (frameTime <= elapsedTime) {
                targetFrame = i;
              } else {
                break;
              }
            }

            if (targetFrame < this.ghostData.length) {
              this.currentFrame = targetFrame;
              const frame = this.ghostData[targetFrame];
              this.x = frame.x;
              this.y = frame.y;
              this.angle = frame.angle;
            } else {
              // Ghost has finished, make it inactive
              this.isActive = false;
            }
          }
        }
      }

      // Show time trial complete screen
      function showTimeTrialComplete(lapData) {
        gameRunning = false;
        
        // Display lap time
        const minutes = Math.floor(lapData.lapTime / 60);
        const seconds = (lapData.lapTime % 60).toFixed(3);
        document.getElementById("timeTrialLapTime").textContent = `${minutes}:${seconds.padStart(6, "0")}`;
        
        // Check if this is a new best lap
        const isNewBest = !bestTimeTrialLap || lapData.lapTime < bestTimeTrialLap.lapTime;
        
        if (isNewBest) {
          document.getElementById("timeTrialResult").textContent = "NEW BEST LAP!";
          document.getElementById("timeTrialResult").style.color = "var(--accent-color)";
        } else {
          const improvement = lapData.lapTime - bestTimeTrialLap.lapTime;
          const impMinutes = Math.floor(Math.abs(improvement) / 60);
          const impSeconds = (Math.abs(improvement) % 60).toFixed(3);
          document.getElementById("timeTrialResult").textContent = `+${impMinutes}:${impSeconds.padStart(6, "0")} from best`;
          document.getElementById("timeTrialResult").style.color = "var(--text-secondary)";
        }
        
        // Show the complete screen
        document.getElementById("timeTrialComplete").style.display = "block";
      }

      // Draw ghost car
      function drawGhostCar(ghost) {
        if (!ghost.isActive) return;

        ctx.save();
        ctx.globalAlpha = 0.4; // Make ghost translucent
        
        // Position and orient the ghost car
        ctx.translate(ghost.x, ghost.y);
        ctx.rotate(ghost.angle);

        // Draw a simplified ghost car
        const width = 20;
        const height = 10;

        // Ghost car body
        ctx.fillStyle = "rgba(100, 150, 255, 0.6)";
        ctx.beginPath();
        ctx.moveTo(width / 2, 0);
        ctx.quadraticCurveTo(width / 3, -height / 2, -width / 3, -height / 2);
        ctx.quadraticCurveTo(-width / 2, 0, -width / 3, height / 2);
        ctx.quadraticCurveTo(width / 3, height / 2, width / 2, 0);
        ctx.closePath();
        ctx.fill();

        // Ghost car outline
        ctx.strokeStyle = "rgba(150, 200, 255, 0.8)";
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      }

      // Update time trial ghost list in UI
      function updateTimeTrialGhostList() {
        const list = document.getElementById("timeTrialGhostList");
        if (!list) return;
        
        list.innerHTML = "";
        
        timeTrialGhosts.forEach((ghost, index) => {
          const div = document.createElement("div");
          div.className = "time-trial-ghost-item";
          
          const minutes = Math.floor(ghost.lapTime / 60);
          const seconds = (ghost.lapTime % 60).toFixed(3);
          
          div.innerHTML = `
            <span>${ghost.playerName} - ${minutes}:${seconds.padStart(6, "0")}</span>
            <button onclick="removeTimeTrialGhost(${index})">Remove</button>
          `;
          
          list.appendChild(div);
        });
      }

      function calculateCurrentSpeed() {
        return Math.sqrt(
          player.velocity.x * player.velocity.x +
            player.velocity.y * player.velocity.y
        );
      }

      function handlePlayerInputs() {
        let steering = 0;
        if (keys["KeyA"] || keys["ArrowLeft"]) {
          steering = -1;
        } else if (keys["KeyD"] || keys["ArrowRight"]) {
          steering = 1;
        }

        return {
          acceleration: keys["KeyW"] || keys["ArrowUp"] ? 1 : 0,
          braking: keys["KeyS"] || keys["ArrowDown"] ? 1.2 : 0,
          steering: steering,
        };
      }

      function handleNitroSystem(inputs) {
        player.usingNitro = false;

        if (keys["Space"] && player.nitro > 0) {
          player.usingNitro = true;
          player.nitro -= 1.5;
          inputs.acceleration *= 1.8;

          createNitroFlames();
        } else if (player.nitro < player.maxNitro) {
          player.nitro = Math.min(
            player.maxNitro,
            player.nitro + player.nitroRegenRate * 1.1
          );
        }
      }

      function createNitroFlames() {
        const flameX = player.x + Math.cos(player.angle + Math.PI) * 15;
        const flameY = player.y + Math.sin(player.angle + Math.PI) * 15;
        addFlame(flameX, flameY, player.angle, 2.0);
        addFlame(flameX - 3, flameY - 3, player.angle, 1.5);
        addFlame(flameX + 3, flameY + 3, player.angle, 1.5);
      }

      function handleSteering(steeringInput, currentSpeed) {
        if (steeringInput === 0) return;

        const speedFactor = Math.max(0.4, Math.min(1.0, currentSpeed / 4));
        const baseTurnRate = player.turnSpeed * (1.5 - speedFactor * 0.4);

        player.angle += steeringInput * baseTurnRate;

        if (Math.abs(steeringInput) > 0.7 && currentSpeed > 2.5) {
          addTireMark(player.x, player.y, player.angle);
        }
      }

      function handleAcceleration(accelerationInput) {
        if (accelerationInput <= 0) return;

        const forwardX =
          Math.cos(player.angle) * player.acceleration * accelerationInput;
        const forwardY =
          Math.sin(player.angle) * player.acceleration * accelerationInput;
        player.velocity.x += forwardX;
        player.velocity.y += forwardY;
      }

      function handleBraking(brakingInput, currentSpeed) {
        if (brakingInput <= 0) return;

        const velocityMagnitude = Math.sqrt(
          player.velocity.x * player.velocity.x +
            player.velocity.y * player.velocity.y
        );

        if (velocityMagnitude > 0.1) {
          const brakeForce = brakingInput * player.acceleration * 1.8;
          const normalizedVelX = player.velocity.x / velocityMagnitude;
          const normalizedVelY = player.velocity.y / velocityMagnitude;

          player.velocity.x -= normalizedVelX * brakeForce;
          player.velocity.y -= normalizedVelY * brakeForce;

          if (brakingInput > 0.6 && currentSpeed > 2) {
            addTireMark(player.x, player.y, player.angle);
          }
        }
      }

      function limitSpeed() {
        const maxSpeed = player.usingNitro
          ? player.maxSpeed * 1.3
          : player.maxSpeed;
        const speed = Math.sqrt(
          player.velocity.x * player.velocity.x +
            player.velocity.y * player.velocity.y
        );

        if (speed > maxSpeed) {
          player.velocity.x = (player.velocity.x / speed) * maxSpeed;
          player.velocity.y = (player.velocity.y / speed) * maxSpeed;
        }
      }

      function updatePosition() {
        player.x += player.velocity.x;
        player.y += player.velocity.y;
      }

      function updateTireWear(inputs, currentSpeed) {
        if (!gameRunning) return;

        const speedWearFactor = currentSpeed / player.maxSpeed;
        const inputWearFactor =
          Math.abs(inputs.steering) * 0.5 + Math.abs(inputs.braking) * 0.3;

        player.tireWear = Math.min(
          100,
          player.tireWear +
            player.tireWearRate * (1 + speedWearFactor + inputWearFactor)
        );
      }

      function applyFriction(currentSpeed) {
        const baseFriction = 0.985;
        const tireGripLoss = gameRunning ? player.tireWear / 400 : 0;
        const combinedFriction = Math.max(
          0.975,
          baseFriction - currentSpeed * 0.001 - tireGripLoss
        );

        player.velocity.x *= combinedFriction;
        player.velocity.y *= combinedFriction;
      }

      function updatePlayerSpeed() {
        player.speed = Math.sqrt(
          player.velocity.x * player.velocity.x +
            player.velocity.y * player.velocity.y
        );
      }

      function constrainToBounds() {
        const worldBounds = 2500;

        if (
          player.x < -200 ||
          player.x > worldBounds ||
          player.y < -200 ||
          player.y > worldBounds
        ) {
          player.x = Math.max(-150, Math.min(worldBounds - 50, player.x));
          player.y = Math.max(-150, Math.min(worldBounds - 50, player.y));
          player.velocity.x *= 0.85;
          player.velocity.y *= 0.85;
        }
      }

      // AI update system with realistic racing behavior
      function updateAI() {
        const allCars = [player, ...aiCars];
        aiCars.forEach((ai) => {
          updateSingleAI(ai, allCars);
        });
      }

      function updateSingleAI(ai, allCars) {
        if (handleStunnedAI(ai)) return;

        handleRaceStartProtection(ai);
        const target = getBehaviorTarget(ai, allCars);
        updateWaypointProgression(ai);

        const angleDiff = calculateSteering(ai, target);
        const accelerationMultiplier = calculateAccelerationMultiplier(
          ai,
          target,
          angleDiff
        );

        handleAINitroSystem(ai, allCars, target, accelerationMultiplier);
        applyMovementForces(ai, accelerationMultiplier);
        updatePhysics(ai, angleDiff);
        checkBounds(ai);
      }

      function handleStunnedAI(ai) {
        if (ai.stunned > 0) {
          ai.stunned--;
          if (ai.stunned > 0) {
            ai.velocity.x *= 0.98;
            ai.velocity.y *= 0.98;
            return true;
          }
        }
        return false;
      }

      function handleRaceStartProtection(ai) {
        const raceTime = gameRunning ? (Date.now() - raceStartTime) / 1000 : 0;

        // Only apply race start protection during the actual race, not before it starts
        if (gameRunning && raceTime < 3) {
          // Provide a gentle forward impulse to ensure cars move forward across the start line
          // This helps them pick up the start/finish checkpoint
          if (ai.velocity.y > -0.5) {
            // Only add velocity if they're not already moving fast enough
            // This is a gentle boost that doesn't force orientation, just helps ensure movement
            ai.velocity.y = Math.min(ai.velocity.y - 0.1, -0.5);
          }
        }
      }

      function getBehaviorTarget(ai, allCars) {
        const target = ai.behavior.update(allCars, track);

        if (!target || isNaN(target.x) || isNaN(target.y)) {
          const fallbackWaypoint = track.waypoints[ai.targetWaypoint];
          return { x: fallbackWaypoint.x, y: fallbackWaypoint.y };
        }

        return target;
      }

      function updateWaypointProgression(ai) {
        const currentWaypoint = track.waypoints[ai.targetWaypoint];
        const dx = currentWaypoint.x - ai.x;
        const dy = currentWaypoint.y - ai.y;
        const waypointDistance = Math.sqrt(dx * dx + dy * dy);

        const switchDistance = 60 + ai.behavior.awareness * 40;
        if (waypointDistance < switchDistance) {
          ai.targetWaypoint = (ai.targetWaypoint + 1) % track.waypoints.length;
        }
      }

      function calculateSteering(ai, target) {
        const targetDx = target.x - ai.x;
        const targetDy = target.y - ai.y;
        const targetAngle = Math.atan2(targetDy, targetDx);

        let angleDiff = targetAngle - ai.angle;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        const baseSteerRate = ai.turnSpeed;
        const skillMultiplier = 0.5 + ai.behavior.cornering_skill * 0.8;
        const smoothnessMultiplier = 0.3 + ai.behavior.smoothness * 0.7;
        const adjustedSteerRate =
          baseSteerRate * skillMultiplier * smoothnessMultiplier;

        const maxSteer =
          adjustedSteerRate * (1 + ai.behavior.aggressiveness * 0.3);
        let steerAmount = Math.max(
          -maxSteer,
          Math.min(maxSteer, angleDiff * 0.4)
        );

        if (ai.behavior.smoothness < 0.7) {
          steerAmount +=
            (Math.random() - 0.5) * 0.02 * (1 - ai.behavior.smoothness);
        }

        ai.angle += steerAmount;
        return angleDiff;
      }

      function calculateAccelerationMultiplier(ai, target, angleDiff) {
        let accelerationMultiplier = ai.behavior.pace_consistency;

        accelerationMultiplier *= getBehaviorSpeedModifier(ai);
        accelerationMultiplier *= getCornerSpeedModifier(ai, target);
        accelerationMultiplier *= getBrakingModifier(ai, angleDiff);

        return accelerationMultiplier;
      }

      function getBehaviorSpeedModifier(ai) {
        switch (ai.behavior.state) {
          case "overtaking":
            return 1.2 + ai.behavior.overtaking_ability * 0.3;
          case "defending":
            return 0.9 + ai.behavior.defending_skill * 0.2;
          case "avoiding":
            return 0.7 + ai.behavior.awareness * 0.2;
          case "racing":
            return 0.95 + ai.behavior.aggressiveness * 0.15;
          default:
            return 1.0;
        }
      }

      function getCornerSpeedModifier(ai, target) {
        const targetDx = target.x - ai.x;
        const targetDy = target.y - ai.y;
        const targetDistance = Math.sqrt(
          targetDx * targetDx + targetDy * targetDy
        );

        if (targetDistance < 60) {
          return 0.6 + ai.behavior.cornering_skill * 0.4;
        }
        return 1.0;
      }

      function getBrakingModifier(ai, angleDiff) {
        const currentSpeed = Math.sqrt(
          ai.velocity.x * ai.velocity.x + ai.velocity.y * ai.velocity.y
        );

        if (
          Math.abs(angleDiff) > Math.PI / 4 &&
          currentSpeed > ai.maxSpeed * 0.7
        ) {
          if (ai.behavior.braking_style > 0.6) {
            return 0.85; // Late braker
          } else {
            return 0.75; // Conservative braker
          }
        }
        return 1.0;
      }

      function handleAINitroSystem(
        ai,
        allCars,
        target,
        accelerationMultiplier
      ) {
        ai.usingNitro = false;
        const currentTime = Date.now();

        if (ai.nitro < ai.maxNitro) {
          ai.nitro += ai.nitroRegenRate;
          ai.nitro = Math.min(ai.nitro, ai.maxNitro);
        }

        const targetDx = target.x - ai.x;
        const targetDy = target.y - ai.y;
        const targetDistance = Math.sqrt(
          targetDx * targetDx + targetDy * targetDy
        );

        if (ai.nitro > 25 && currentTime - ai.lastNitroUse > 1500) {
          const shouldUseNitro = shouldAIUseNitro(ai, allCars, targetDistance);
          if (shouldUseNitro) {
            ai.usingNitro = true;
            ai.nitro -= 1.8;
            ai.lastNitroUse = currentTime;

            createAINitroFlames(ai);
          }
        }
      }

      function createAINitroFlames(ai) {
        const flameX = ai.x + Math.cos(ai.angle + Math.PI) * 12;
        const flameY = ai.y + Math.sin(ai.angle + Math.PI) * 12;
        addFlame(flameX, flameY, ai.angle, 1.4);
        addFlame(
          flameX + (Math.random() - 0.5) * 4,
          flameY + (Math.random() - 0.5) * 4,
          ai.angle,
          1.2
        );
      }

      function applyMovementForces(ai, accelerationMultiplier) {
        const effectiveAcceleration = ai.usingNitro
          ? accelerationMultiplier * 1.6
          : accelerationMultiplier;
        const forwardForce = ai.acceleration * effectiveAcceleration;
        const throttleStyle = 0.7 + ai.behavior.throttle_style * 0.3;

        const forceX = Math.cos(ai.angle) * forwardForce * throttleStyle;
        const forceY = Math.sin(ai.angle) * forwardForce * throttleStyle;

        ai.velocity.x += forceX;
        ai.velocity.y += forceY;

        limitAISpeed(ai);
      }

      function limitAISpeed(ai) {
        let effectiveMaxSpeed = ai.maxSpeed;
        if (ai.behavior.state === "overtaking") {
          effectiveMaxSpeed *= 1.08 + ai.behavior.overtaking_ability * 0.12;
        }
        if (ai.usingNitro) {
          effectiveMaxSpeed *= 1.4;
        }

        const speed = Math.sqrt(
          ai.velocity.x * ai.velocity.x + ai.velocity.y * ai.velocity.y
        );
        if (speed > effectiveMaxSpeed) {
          ai.velocity.x = (ai.velocity.x / speed) * effectiveMaxSpeed;
          ai.velocity.y = (ai.velocity.y / speed) * effectiveMaxSpeed;
        }
      }

      /**
       * Physics Update System
       * Applies position updates, tire degradation, friction, and collision detection to AI cars.
       * This function integrates all physics forces acting on the car each frame.
       */
      function updatePhysics(ai, steerAmount) {
        // Update position based on current velocity vectors
        ai.x += ai.velocity.x;
        ai.y += ai.velocity.y;

        // Simulate tire wear based on speed and steering intensity
        updateAITireWear(ai, steerAmount);

        // Apply friction forces that slow the car down naturally
        applyAIFriction(ai);

        // Check for collisions with track boundaries and apply penalties
        handleTrackCollision(ai);

        // Calculate final speed magnitude from velocity components for UI display
        ai.speed = Math.sqrt(
          ai.velocity.x * ai.velocity.x + ai.velocity.y * ai.velocity.y
        );
      }

      /**
       * Tire Wear Simulation for AI Cars
       * Calculates realistic tire degradation based on speed and steering input.
       * Higher speeds and aggressive steering cause faster tire wear.
       */
      function updateAITireWear(ai, steerAmount) {
        if (gameRunning) {
          // Calculate current speed for wear calculation
          const currentSpeedAI = Math.sqrt(
            ai.velocity.x * ai.velocity.x + ai.velocity.y * ai.velocity.y
          );

          // Normalize speed to create wear factor (0-1 range)
          const speedWearFactor = currentSpeedAI / ai.maxSpeed;

          // Steering wear - sharp turns damage tires more
          const steerWearFactor = Math.abs(steerAmount) * 0.3;

          // Apply cumulative tire wear with speed and steering penalties
          ai.tireWear = Math.min(
            100,
            ai.tireWear +
              ai.tireWearRate * (1 + speedWearFactor + steerWearFactor)
          );
        }
      }

      /**
       * Friction Application System for AI Cars
       * Applies various friction forces including tire grip loss and AI personality smoothness.
       * This creates realistic deceleration when not accelerating.
       */
      function applyAIFriction(ai) {
        // Base friction coefficient for natural deceleration
        const personalityFriction = 0.985;

        // Tire wear reduces grip - worn tires slide more
        const tireGripLoss = gameRunning ? ai.tireWear / 500 : 0;

        // Smooth drivers maintain better tire contact and grip
        const smoothnessBonus = ai.behavior.smoothness * 0.005;

        // Combine all friction factors with minimum threshold
        const combinedFrictionAI = Math.max(
          0.975,
          personalityFriction + smoothnessBonus - tireGripLoss
        );

        // Apply friction to both velocity components
        ai.velocity.x *= combinedFrictionAI;
        ai.velocity.y *= combinedFrictionAI;
      }

      function checkBounds(ai) {
        const trackBounds = 2500;
        if (
          ai.x < -200 ||
          ai.x > trackBounds ||
          ai.y < -200 ||
          ai.y > trackBounds
        ) {
          const nearestWaypoint = track.waypoints[ai.targetWaypoint];
          ai.x = nearestWaypoint.x + (Math.random() - 0.5) * 60;
          ai.y = nearestWaypoint.y + (Math.random() - 0.5) * 60;
          ai.velocity.x *= 0.3;
          ai.velocity.y *= 0.3;
        }
      }

      // AI Nitro Decision System
      function shouldAIUseNitro(ai, allCars, targetDistance) {
        const currentSpeed = Math.sqrt(
          ai.velocity.x * ai.velocity.x + ai.velocity.y * ai.velocity.y
        );

        // Strategy 1: Use nitro on straight sections (low turn angle)
        const currentWaypoint = track.waypoints[ai.targetWaypoint];
        const nextWaypoint =
          track.waypoints[(ai.targetWaypoint + 1) % track.waypoints.length];
        const straightLine = calculateStraightness(
          ai,
          currentWaypoint,
          nextWaypoint
        );

        // Strategy 2: Use nitro for overtaking opportunities
        const carsAhead = allCars.filter((car) => {
          if (car === ai) return false;
          const distance = Math.sqrt(
            (car.x - ai.x) * (car.x - ai.x) + (car.y - ai.y) * (car.y - ai.y)
          );
          return (
            distance < 100 && distance > 20 && car.lapProgress >= ai.lapProgress
          );
        });

        // Strategy 3: Use nitro when behind and need to catch up
        const playerDistance = Math.sqrt(
          (player.x - ai.x) * (player.x - ai.x) +
            (player.y - ai.y) * (player.y - ai.y)
        );
        const isBehindPlayer = ai.lapProgress < player.lapProgress;

        // Strategy 4: Defensive nitro when player is close behind
        const playerBehind =
          playerDistance < 60 && player.lapProgress < ai.lapProgress;

        // Decision logic based on AI personality (nitroStrategy)
        let useNitro = false;

        if (ai.nitroStrategy > 0.6) {
          // Aggressive AI - made more likely to use nitro
          useNitro =
            straightLine > 0.6 ||
            carsAhead.length > 0 ||
            (isBehindPlayer && playerDistance < 200);
        } else if (ai.nitroStrategy > 0.4) {
          // Balanced AI conditions for realistic racing
          useNitro =
            (straightLine > 0.7 && currentSpeed < ai.maxSpeed * 0.85) ||
            (carsAhead.length > 0 && ai.behavior.state === "overtaking") ||
            playerBehind ||
            (straightLine > 0.8 && Math.random() < 0.3);
        } else {
          // Conservative AI - more willing to use nitro
          useNitro =
            (straightLine > 0.8 && carsAhead.length > 0) ||
            (playerBehind && ai.nitro > 40) || // Lower threshold
            (straightLine > 0.9 && Math.random() < 0.2); // Occasional use on straights
        }

        // Don't use nitro if already at high speed or on tight corners
        if (currentSpeed > ai.maxSpeed * 0.9 || straightLine < 0.3) {
          useNitro = false;
        }

        return useNitro;
      }

      function calculateStraightness(ai, currentWP, nextWP) {
        const toCurrentX = currentWP.x - ai.x;
        const toCurrentY = currentWP.y - ai.y;
        const toNextX = nextWP.x - currentWP.x;
        const toNextY = nextWP.y - currentWP.y;

        // Calculate angle difference - closer to 0 means straighter line
        const angle1 = Math.atan2(toCurrentY, toCurrentX);
        const angle2 = Math.atan2(toNextY, toNextX);
        let angleDiff = Math.abs(angle2 - angle1);
        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;

        // Convert to straightness factor (1 = perfectly straight, 0 = 90 degree turn)
        return 1 - angleDiff / Math.PI;
      }

      // Global race state
      let raceLeader = null;
      let lastLapCheckpoint = 0; // Track which checkpoint marks the last lap completion

      // Check player checkpoints
      /**
       * Checkpoint validation system - Ensures cars complete laps correctly and prevents shortcutting
       * Uses a sequential checkpoint system where cars must hit checkpoints in the correct order
       * @param {Object} car - The car object to check (player or AI)
       */
      /**
       * Checkpoint Validation System with Anti-Cheat Protection
       *
       * This function ensures all cars progress through checkpoints in the correct sequence
       * and provides different detection methods for start/finish vs regular checkpoints.
       *
       * Features:
       * - Wider rectangular detection for start/finish line (accommodates different racing lines)
       * - Circular detection for corner checkpoints (prevents cutting corners)
       * - Sequential checkpoint validation (prevents lap exploits)
       * - Checkpoint timing for gap calculations and telemetry
       *
       * @param {Object} car - The car object to check (player or AI)
       */
      function checkCarCheckpoints(car) {
        const checkpoints = track.checkpoints;
        const nextCheckpointIndex = car.currentCheckpoint;

        // Safety check: if somehow all checkpoints completed, reset for next lap
        if (nextCheckpointIndex >= checkpoints.length) {
          car.currentCheckpoint = 0; // Reset to start/finish line
          return;
        }

        const nextCheckpoint = checkpoints[nextCheckpointIndex];
        let checkpointHit = false;

        // Special collision detection for start/finish line (checkpoint 0)
        // Uses a wider rectangular area to accommodate different racing lines
        if (nextCheckpointIndex === 0) {
          // Wide finish line area spans the track width to catch cars using inside/outside lines
          const finishY = nextCheckpoint.y;
          const finishCenterX = nextCheckpoint.x;
          // Generous finish line detection area to accommodate all racing lines
          const finishWidth = 320; // Increased from 280 to ensure wide lines are detected
          const finishHeight = 140; // Increased from 120 for better coverage

          // Check if car is within the finish line area
          if (
            car.y >= finishY - finishHeight / 2 &&
            car.y <= finishY + finishHeight / 2 &&
            car.x >= finishCenterX - finishWidth / 2 &&
            car.x <= finishCenterX + finishWidth / 2
          ) {
            checkpointHit = true;
          }
        } else {
          // Regular circular checkpoint detection for other checkpoints - wider detection area
          const dx = nextCheckpoint.x - car.x;
          const dy = nextCheckpoint.y - car.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 80) { // Increased from 45 to accommodate wider racing lines in all weather conditions
            checkpointHit = true;
          }
        }

        // Process checkpoint hit - but only if car is properly on track
        if (checkpointHit) {
          // Additional validation: car must be on track to hit checkpoint
          if (!isPointOnTrack(car.x, car.y)) {
            // Car is off track, don't count the checkpoint
            return;
          }
          
          // Record checkpoint time for gap calculations
          const currentTime = gameRunning ? Date.now() : 0;
          if (!car.checkpointTimes) {
            car.checkpointTimes = {};
          }
          car.checkpointTimes[`${car.lapsCompleted}_${nextCheckpointIndex}`] =
            currentTime;

          // Mark this checkpoint as hit
          car.checkpointsHit[nextCheckpointIndex] = true;
          car.currentCheckpoint++;

          // Check if this completes a lap (hitting checkpoint 0 after completing all others)
          if (nextCheckpointIndex === 0) {
            // Check if all checkpoints were hit in sequence
            const allCheckpointsHit = car.checkpointsHit.every((hit) => hit);
            if (allCheckpointsHit && car.lapsCompleted > 0) {
              // Completed a full lap
              car.lapsCompleted++;

              // Track lap times for all cars
              if (gameRunning) {
                const currentTime = Date.now();

                // Calculate and store lap time
                if (car.currentLapStartTime > 0) {
                  const lapTime =
                    (currentTime - car.currentLapStartTime) / 1000;
                  car.lapTimes.push(lapTime);
                  car.totalRaceTime += lapTime;

                  // Additional tracking for player car
                  if (car === player) {
                    currentLapTime = lapTime;
                    lastLapTime = lapTime; // Store the last completed lap time
                    lapTimes.push(currentLapTime);

                    // Handle time trial lap completion
                    if (isTimeTrialMode) {
                      completeTimeTrialLap(lapTime);
                      return; // Exit early for time trial - single lap only
                    }

                    // Update best lap time for current race
                    if (currentLapTime < bestLapTime) {
                      bestLapTime = currentLapTime;
                      
                      // Check if this is also an all-time lap record
                      if (currentLapTime < lapRecord) {
                        lapRecord = currentLapTime;
                        
                        // Show a lap record notification
                        const notification = document.createElement("div");
                        notification.className = "lap-record-notification";
                        notification.textContent = "NEW LAP RECORD!";
                        notification.style.cssText = `
                          position: absolute;
                          top: 30%;
                          left: 50%;
                          transform: translate(-50%, -50%);
                          background: rgba(255, 215, 0, 0.8);
                          color: #000;
                          padding: 15px 30px;
                          border-radius: 8px;
                          font-family: 'Orbitron', sans-serif;
                          font-size: 24px;
                          font-weight: bold;
                          box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
                          z-index: 9999;
                          animation: recordPulse 2s forwards;
                        `;
                        document.body.appendChild(notification);
                        
                        // Add CSS animation if not already added
                        if (!document.getElementById("recordAnimation")) {
                          const style = document.createElement("style");
                          style.id = "recordAnimation";
                          style.textContent = `
                            @keyframes recordPulse {
                              0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                              20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                              40% { transform: translate(-50%, -50%) scale(0.9); }
                              60% { transform: translate(-50%, -50%) scale(1.1); }
                              80% { opacity: 1; }
                              100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                            }
                          `;
                          document.head.appendChild(style);
                        }
                        
                        // Remove notification after animation
                        setTimeout(() => {
                          notification.remove();
                        }, 2000);
                      }
                    }

                    // Update player's lap start time
                    lapStartTime = currentTime;
                  }
                }

                // Start timing for next lap for all cars
                car.currentLapStartTime = currentTime;
              }

              // Reset for next lap
              car.currentCheckpoint = 1; // Next checkpoint after start/finish
              car.checkpointsHit = [true, false, false];

              console.log(
                `${car.name || "Player"} completed lap ${car.lapsCompleted}`
              );
            } else if (car.lapsCompleted === 0) {
              // First time hitting start/finish - start first lap
              car.lapsCompleted = 1;

              // Initialize lap timing for all cars
              if (gameRunning) {
                const currentTime = Date.now();
                car.currentLapStartTime = currentTime;

                // Additional tracking for player car
                if (car === player) {
                  lapStartTime = currentTime;
                }
              }
              car.currentCheckpoint = 1;
              car.checkpointsHit = [true, false, false];

              // Initialize lap timing for player
              if (car === player && gameRunning) {
                lapStartTime = Date.now();
              }

              console.log(`${car.name || "Player"} completed lap 1`);
            }
          }

          // Update lap progress for positioning (total laps + progress through current lap)
          car.lapProgress =
            car.lapsCompleted + car.currentCheckpoint / checkpoints.length;
        }
      }

      function checkPlayerCheckpoints() {
        checkCarCheckpoints(player);
      }

      // Check AI checkpoints
      function checkAICheckpoints() {
        aiCars.forEach((ai) => {
          checkCarCheckpoints(ai);
        });
      }

      // Check if race is complete
      function checkRaceCompletion() {
        const allCars = [
          { ...player, name: "Player", isPlayer: true },
          ...aiCars,
        ];

        // Find the race leader (car with most laps completed)
        allCars.sort((a, b) => b.lapsCompleted - a.lapsCompleted);
        const raceLeader = allCars[0];

        // Update global currentLap based on race leader's progress
        if (raceLeader.lapsCompleted > 0) {
          currentLap = Math.min(raceLeader.lapsCompleted + 1, totalLaps);
        }

        // Race only ends when the player completes their 5th lap
        if (player.lapsCompleted >= totalLaps && !raceComplete) {
          // Save final race standings before marking race as complete
          const finalStandings = [
            { ...player, name: "Player", isPlayer: true },
            ...aiCars,
          ];
          
          // Calculate final race progress for all cars
          calculateRaceProgress(finalStandings);
          
          // Sort cars by race progress
          finalStandings.sort((a, b) => {
            // First sort by laps completed
            if (b.lapsCompleted !== a.lapsCompleted) {
              return b.lapsCompleted - a.lapsCompleted;
            }

            // Then by checkpoint within the same lap
            if (b.currentCheckpoint !== a.currentCheckpoint) {
              return b.currentCheckpoint - a.currentCheckpoint;
            }

            // If at same lap and checkpoint, sort by calculated race time
            return a.calculatedTotalTime - b.calculatedTotalTime;
          });
          
          // Save position information
          finalStandings.forEach((car, index) => {
            car.racePosition = index + 1;
            if (car.isPlayer) {
              player.racePosition = index + 1;
            }
          });
          
          // Store these standings for use after race completion
          finalRaceStandings = finalStandings;
          
          raceComplete = true;
          gameRunning = false;
          showRaceComplete();
        }
      }

      // Update race positions
      function updatePositions() {
        const allCars = [
          { ...player, name: "Player", isPlayer: true },
          ...aiCars,
        ];

        calculateRaceProgress(allCars);

        // First, pre-calculate time gaps for each car relative to their total race time
        // This will be used for sorting within the same lap/checkpoint
        const currentTime = Date.now();

        allCars.forEach((car) => {
          // Calculate total race time including current lap in progress
          let totalTime = car.totalRaceTime || 0;
          if (car.currentLapStartTime > 0) {
            const currentLapTime =
              (currentTime - car.currentLapStartTime) / 1000;
            totalTime += currentLapTime;
          }
          car.calculatedTotalTime = totalTime;
        });

        // First, sort by basic race progress (lap + checkpoint)
        allCars.sort((a, b) => {
          // First sort by laps completed
          if (b.lapsCompleted !== a.lapsCompleted) {
            return b.lapsCompleted - a.lapsCompleted;
          }

          // Then by checkpoint within the same lap
          if (b.currentCheckpoint !== a.currentCheckpoint) {
            return b.currentCheckpoint - a.currentCheckpoint;
          }

          // If they're at the same lap and checkpoint,
          // sort by their calculated total race time (lower is better)
          const timeDiff = a.calculatedTotalTime - b.calculatedTotalTime;

          // If times are very close (but not identical), still use the actual times
          // without any artificial epsilon for true accuracy
          return timeDiff;
        });

        // Calculate time gaps to the leader for all cars
        const leader = allCars[0];
        for (let i = 1; i < allCars.length; i++) {
          allCars[i].gapToLeader = calculateGapInSeconds(leader, allCars[i], i);
        }

        // Group cars that share the same lap and checkpoint
        const finalSortedCars = [];
        let currentGroup = [];
        let currentLap = -1;
        let currentCheckpoint = -1;

        // Group cars by lap and checkpoint
        for (const car of allCars) {
          if (
            car.lapsCompleted !== currentLap ||
            car.currentCheckpoint !== currentCheckpoint
          ) {
            // Add previous group to final array
            if (currentGroup.length > 0) {
              // Group is already sorted by calculatedTotalTime from the initial sort
              finalSortedCars.push(...currentGroup);
              currentGroup = [];
            }

            // Start new group
            currentLap = car.lapsCompleted;
            currentCheckpoint = car.currentCheckpoint;
          }
          currentGroup.push(car);
        }

        // Add the last group
        if (currentGroup.length > 0) {
          finalSortedCars.push(...currentGroup);
        }

        logPositionDebugInfo(finalSortedCars);
        updateCarPositions(finalSortedCars);
        updatePositionDisplay(finalSortedCars);
      }

      function calculateRaceProgress(allCars) {
        allCars.forEach((car) => {
          let baseProgress =
            car.lapsCompleted +
            car.currentCheckpoint / track.checkpoints.length;

          const nextCheckpointIndex =
            car.currentCheckpoint % track.checkpoints.length;
          const nextCheckpoint = track.checkpoints[nextCheckpointIndex];

          if (nextCheckpoint) {
            const distanceToNext = Math.sqrt(
              Math.pow(car.x - nextCheckpoint.x, 2) +
                Math.pow(car.y - nextCheckpoint.y, 2)
            );

            const maxDistance = 2000;
            const distanceProgress = Math.max(
              0,
              (1 - distanceToNext / maxDistance) * 0.33
            );
            baseProgress += distanceProgress;
          }

          car.raceProgress = baseProgress;
        });
      }

      function logPositionDebugInfo(allCars) {
        const shouldLog =
          Math.floor(Date.now() / 1000) % 5 === 0 &&
          (!this.lastDebugTime ||
            Date.now() - (this.lastDebugTime || 0) > 5000);

        if (shouldLog) {
          // Format: POS | Name | Lap X/5 | Sector Y | Last Lap: MM:SS.sss | Gap: +X.Xs | Raw Time
          const debugText = allCars
            .map((car, index) => {
              // Format position
              const positionText = `P${index + 1}`;

              // Format lap info
              const lapInfo = `Lap ${car.lapsCompleted}/${totalLaps}`;

              // Format sector info
              const sectorMap = { 0: "S/F", 1: "S1", 2: "S2" };
              const sector = sectorMap[car.currentCheckpoint] || "??";

              // Format last lap time
              const lastLapTime =
                car.lapTimes.length > 0
                  ? formatTime(car.lapTimes[car.lapTimes.length - 1])
                  : "--:--";

              // Format gap to leader
              const leader = allCars[0];
              const gapInSeconds =
                index === 0 ? 0 : calculateGapInSeconds(leader, car, index);
              const gapText =
                index === 0 ? "LEADER" : `+${gapInSeconds.toFixed(3)}s`;

              // Format calculated total time for debugging (raw, unrounded)
              const totalTimeText =
                car.calculatedTotalTime !== undefined
                  ? `Raw: ${car.calculatedTotalTime.toFixed(6)}s`
                  : "No time";

              return `${positionText} | ${
                car.name || "Player"
              } | ${lapInfo} | ${sector} | Last: ${lastLapTime} | ${gapText} | ${totalTimeText}`;
            })
            .join("\n");

          console.log("RACE STANDINGS (EXACT TIMES):\n" + debugText);
          this.lastDebugTime = Date.now();
        }
      }

      // Helper function to format time as MM:SS.sss
      function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = (seconds % 60).toFixed(3);
        return `${minutes}:${secs.padStart(6, "0")}`;
      }

      function updateCarPositions(allCars) {
        allCars.forEach((car, index) => {
          car.racePosition = index + 1;
          if (car.isPlayer) {
            player.racePosition = index + 1;
          }
        });
      }

      function updatePositionDisplay(allCars) {
        const positionList = document.getElementById("positionList");
        positionList.innerHTML = "";

        // Use finalRaceStandings instead of allCars if race is complete
        const carsToDisplay = raceComplete ? finalRaceStandings : allCars;

        carsToDisplay.forEach((car, index) => {
          const positionItem = createPositionDisplayItem(car, index, carsToDisplay);
          positionList.appendChild(positionItem);
        });
      }

      function createPositionDisplayItem(car, index, allCars) {
        const div = document.createElement("div");
        div.className = "position-item";
        if (car.isPlayer) div.className += " player-pos";

        const position = index + 1;
        
        // Get 3-letter team abbreviation
        const teamCode = getTeamCode(car);
        
        // Format last lap time
        let lastLapDisplay = "--.---";
        if (car.lapTimes && car.lapTimes.length > 0) {
          const lastLapTime = car.lapTimes[car.lapTimes.length - 1];
          const lastLapMinutes = Math.floor(lastLapTime / 60);
          const lastLapSeconds = (lastLapTime % 60).toFixed(3);
          lastLapDisplay = `${lastLapMinutes}:${lastLapSeconds.padStart(6, "0")}`;
        }

        // Get gap text (already formatted)
        const gapText = calculateGapText(car, index, allCars);
        
        // Current lap info
        const lapInfo = `${car.lapsCompleted}/${totalLaps}`;
        
        const carNameColor = car.isPlayer ? "var(--primary-color)" : "#ffffff";

        // Format: position  3-letter-abbreviation  lap-progress  last-lap-time  gap-to-leader
        div.innerHTML = `
          <span style="color: #cccccc; font-weight: 600; width: 30px; display: inline-block;">${position}</span>
          <span style="color: ${carNameColor}; font-weight: ${car.isPlayer ? "700" : "400"}; width: 50px; display: inline-block;">${teamCode}</span>
          <span style="color: #fff; width: 40px; display: inline-block;">${lapInfo}</span>
          <span style="color: #fff; width: 80px; display: inline-block;">${lastLapDisplay}</span>
          <span style="color: #888; width: 80px; display: inline-block;">${gapText}</span>
        `;

        return div;
      }

      function calculateGapText(car, index, allCars) {
        if (index === 0) {
          return "+0.000s";
        }

        const leader = allCars[0];
        const gapInSeconds = calculateGapInSeconds(leader, car, index);

        // Display the actual gap without position-based artificial inflation
        return formatGapText(gapInSeconds);
      }

      function calculateGapInSeconds(leader, currentCar, position) {
        // If leader and car are identical, return 0
        if (leader === currentCar) {
          return 0;
        }

        // If we already have the calculated total times, use them directly for a consistent gap
        if (
          leader.calculatedTotalTime !== undefined &&
          currentCar.calculatedTotalTime !== undefined
        ) {
          // Use the exact difference between race times for accurate gaps
          // In real F1, identical times to the millisecond are possible (shown as 0.000s)
          // The car that set the time first gets the higher position
          const rawGap =
            currentCar.calculatedTotalTime - leader.calculatedTotalTime;

          // Return the exact gap with no minimum enforcement
          return rawGap;
        }

        // Legacy calculation if calculatedTotalTime is not available
        const lapDifference = leader.lapsCompleted - currentCar.lapsCompleted;

        // Get total race time for both cars (completed laps only)
        let leaderRaceTime = leader.totalRaceTime || 0;
        let currentCarRaceTime = currentCar.totalRaceTime || 0;

        // Add current lap progress time for both cars
        const currentTime = Date.now();

        // Add the time of the current lap in progress
        let leaderCurrentLapTime = 0;
        let currentCarCurrentLapTime = 0;

        if (leader.currentLapStartTime > 0) {
          leaderCurrentLapTime =
            (currentTime - leader.currentLapStartTime) / 1000;
          leaderRaceTime += leaderCurrentLapTime;
        }

        if (currentCar.currentLapStartTime > 0) {
          currentCarCurrentLapTime =
            (currentTime - currentCar.currentLapStartTime) / 1000;
          currentCarRaceTime += currentCarCurrentLapTime;
        }

        // Calculate a more accurate gap based on lap difference and actual times
        let gap;

        if (lapDifference === 0) {
          // On same lap: simple time difference
          gap = currentCarRaceTime - leaderRaceTime;
        } else if (lapDifference > 0) {
          // Leader is ahead by laps: use average lap time to estimate gap
          const leaderAvgLapTime =
            leader.lapTimes.length > 0
              ? leader.lapTimes.reduce((sum, time) => sum + time, 0) /
                leader.lapTimes.length
              : 60; // Default estimate if no lap data

          // Add (lapDifference * avg lap time) to the basic time difference
          gap =
            currentCarRaceTime -
            leaderRaceTime +
            lapDifference * leaderAvgLapTime;
        } else {
          // Leader is behind by laps (shouldn't happen, but just in case)
          gap = currentCarRaceTime - leaderRaceTime;
        }

        // Return the exact calculated gap without any minimum enforcement
        return gap;
      }

      function formatGapText(gapInSeconds) {
        if (gapInSeconds === null || gapInSeconds < 0) {
          return "+0.000s";
        }

        // Display the exact gap including true zeros (like in real F1)
        if (gapInSeconds < 60) {
          return `+${gapInSeconds.toFixed(3)}s`;
        }

        const minutes = Math.floor(gapInSeconds / 60);
        const seconds = (gapInSeconds % 60).toFixed(3);
        return `+${minutes}:${seconds.padStart(6, "0")}`;
      }

      // Track collision detection for larger track
      function isPointOnTrack(x, y) {
        // Special handling for start/finish area - generous but not excessive
        const startFinishArea = {
          centerX: 1000,
          centerY: 1300,
          width: 200, // Wide enough for starting grid formation
          height: 300, // Sufficient height for multiple car rows
        };

        // Check if we're in the start/finish area
        if (
          Math.abs(x - startFinishArea.centerX) <= startFinishArea.width / 2 &&
          Math.abs(y - startFinishArea.centerY) <= startFinishArea.height / 2
        ) {
          return true; // Always allow cars in the starting area
        }

        // Calculate distance from point to track centerline for rest of track
        let minDistance = Infinity;
        let nearestSegment = null;

        for (let i = 0; i < track.waypoints.length; i++) {
          const current = track.waypoints[i];
          const next = track.waypoints[(i + 1) % track.waypoints.length];

          // Distance from point to line segment
          const segmentInfo = distanceToLineSegmentWithInfo(
            x,
            y,
            current.x,
            current.y,
            next.x,
            next.y
          );

          if (segmentInfo.distance < minDistance) {
            minDistance = segmentInfo.distance;
            nearestSegment = segmentInfo;
          }
        }

        // Use nearestSegment for track surface detection
        let trackSurface = "asphalt"; // Default surface type
        let gripModifier = 1.0; // Default grip level

        if (nearestSegment) {
          // Determine surface type based on distance from track center
          const distanceFromCenter = minDistance;
          const trackRadius = track.width / 2;

          if (
            distanceFromCenter > trackRadius - 15 &&
            distanceFromCenter <= trackRadius
          ) {
            // Close to track edge - kerbs with lower grip
            trackSurface = "kerb";
            gripModifier = 0.85; // Reduced grip on kerbs
          } else if (distanceFromCenter > trackRadius) {
            // Off track - grass/gravel
            trackSurface = "grass";
            gripModifier = 0.4; // Much lower grip off track
          }

          // Store surface info for potential use by calling functions
          if (typeof window !== "undefined") {
            window.lastTrackSurfaceInfo = {
              surface: trackSurface,
              gripModifier: gripModifier,
              distanceFromCenter: distanceFromCenter,
              segmentInfo: nearestSegment,
            };
          }
        }

        // Much more restrictive track boundaries to prevent checkpoint skipping
        const trackRadius = track.width / 2 - 5; // Tighter track boundary detection radius
        return minDistance <= trackRadius;
      }

      // Distance calculation with comprehensive track information
      function distanceToLineSegmentWithInfo(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSquared = dx * dx + dy * dy;

        if (lengthSquared === 0) {
          // Degenerate segment - just return distance to point
          const distance = Math.sqrt(
            (px - x1) * (px - x1) + (py - y1) * (py - y1)
          );
          return {
            distance: distance,
            projX: x1,
            projY: y1,
            t: 0,
          };
        }

        const t = Math.max(
          0,
          Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSquared)
        );
        const projX = x1 + t * dx;
        const projY = y1 + t * dy;
        const distance = Math.sqrt(
          (px - projX) * (px - projX) + (py - projY) * (py - projY)
        );

        return {
          distance: distance,
          projX: projX,
          projY: projY,
          t: t,
        };
      }

      // Helper function to check if car is in starting area during race start
      function isInStartingAreaDuringRaceStart(car) {
        const raceTime = gameRunning ? (Date.now() - raceStartTime) / 1000 : 0;
        const startFinishArea = {
          centerX: 1000,
          centerY: 1300,
          width: 200,
          height: 300,
        };

        return (
          raceTime < 2 &&
          Math.abs(car.x - startFinishArea.centerX) <=
            startFinishArea.width / 2 &&
          Math.abs(car.y - startFinishArea.centerY) <=
            startFinishArea.height / 2
        );
      }

      // Helper function to apply surface-specific effects
      function applySurfaceEffects(car, surfaceInfo) {
        if (surfaceInfo.surface === "grass") {
          // Much harsher penalty for going off track
          car.velocity.x *= 0.5; // Reduced from 0.75
          car.velocity.y *= 0.5;

          if (Math.random() < 0.5) { // More frequent effects
            addSparkle(
              car.x + (Math.random() - 0.5) * 20,
              car.y + (Math.random() - 0.5) * 20
            );
          }
        } else if (surfaceInfo.surface === "kerb") {
          car.velocity.x *= 0.85; // Slightly harsher kerb penalty
          car.velocity.y *= 0.85;
        }
      }

      // Helper function to find closest point on track
      function findClosestTrackPoint(car) {
        let closestPoint = null;
        let minDistance = Infinity;
        let bestSegmentInfo = null;

        for (let i = 0; i < track.waypoints.length; i++) {
          const current = track.waypoints[i];
          const next = track.waypoints[(i + 1) % track.waypoints.length];

          const segmentInfo = distanceToLineSegmentWithInfo(
            car.x,
            car.y,
            current.x,
            current.y,
            next.x,
            next.y
          );

          if (segmentInfo.distance < minDistance) {
            minDistance = segmentInfo.distance;
            closestPoint = { x: segmentInfo.projX, y: segmentInfo.projY };
            bestSegmentInfo = segmentInfo;
          }
        }

        return { closestPoint, bestSegmentInfo };
      }

      /**
       * Car Repositioning System for Track Boundary Violations
       *
       * When a car goes off-track, this system smoothly guides it back to a safe position
       * while applying realistic physics effects like velocity damping and tire marks.
       *
       * Process:
       * 1. Calculate outward direction from closest track point
       * 2. Position car at safe distance inside track boundary
       * 3. Apply gradual correction to prevent sudden jumps
       * 4. Adjust velocity to simulate off-track grip loss
       * 5. Add tire marks to show where car went off-track
       */
      function repositionCarOnTrack(car, closestPoint) {
        const outwardX = car.x - closestPoint.x;
        const outwardY = car.y - closestPoint.y;
        const outwardLength = Math.sqrt(
          outwardX * outwardX + outwardY * outwardY
        );

        if (outwardLength <= 0.1) return;

        // Calculate normalized outward direction vector
        const normalX = outwardX / outwardLength;
        const normalY = outwardY / outwardLength;

        // Position car just inside track boundary with safety margin
        const safeDistance = track.width / 2 - 10; // More restrictive positioning
        const targetX = closestPoint.x + normalX * safeDistance;
        const targetY = closestPoint.y + normalY * safeDistance;

        // Apply immediate correction to prevent track cutting
        const correctionStrength = 0.8; // Much more aggressive repositioning
        car.x = car.x + (targetX - car.x) * correctionStrength;
        car.y = car.y + (targetY - car.y) * correctionStrength;

        // Apply physics effects and visual feedback
        adjustCarVelocity(car, normalX, normalY);
        addTireMark(car.x, car.y, car.angle);
      }

      /**
       * Velocity Adjustment for Off-Track Physics
       *
       * Simulates the loss of grip and momentum when a car leaves the track surface.
       * Uses vector decomposition to maintain tangential speed while damping normal impact.
       */
      function adjustCarVelocity(car, normalX, normalY) {
        const velocityMagnitude = Math.sqrt(
          car.velocity.x * car.velocity.x + car.velocity.y * car.velocity.y
        );

        if (velocityMagnitude <= 0.1) return;

        // Decompose velocity into tangential and normal components
        const tangentialX = -normalY; // Perpendicular to normal (track direction)
        const tangentialY = normalX;

        const tangentialComponent =
          car.velocity.x * tangentialX + car.velocity.y * tangentialY;
        const normalComponent =
          car.velocity.x * normalX + car.velocity.y * normalY;

        // Heavily damp the normal component (into track boundary) while preserving tangential
        const dampedNormalComponent = Math.min(0, normalComponent * 0.3);

        car.velocity.x =
          tangentialX * tangentialComponent * 0.98 +
          normalX * dampedNormalComponent;
        car.velocity.y =
          tangentialY * tangentialComponent * 0.98 +
          normalY * dampedNormalComponent;
      }

      // Improved track collision handling
      function handleTrackCollision(car) {
        if (isInStartingAreaDuringRaceStart(car)) {
          return;
        }

        if (!isPointOnTrack(car.x, car.y)) {
          addSparkle(car.x, car.y);

          const surfaceInfo = window.lastTrackSurfaceInfo || {
            surface: "grass",
            gripModifier: 0.4,
            distanceFromCenter: 100,
          };

          // Apply much harsher off-track penalties
          applySurfaceEffects(car, surfaceInfo);
          
          // Additional speed penalty for going off track
          car.velocity.x *= 0.6; // More severe speed reduction
          car.velocity.y *= 0.6;

          const { closestPoint, bestSegmentInfo } = findClosestTrackPoint(car);

          if (closestPoint && bestSegmentInfo) {
            // If car is extremely far off track, teleport immediately
            if (surfaceInfo.distanceFromCenter > track.width) {
              // Immediate teleport for extreme cases
              const normalX = (car.x - closestPoint.x) / surfaceInfo.distanceFromCenter;
              const normalY = (car.y - closestPoint.y) / surfaceInfo.distanceFromCenter;
              const safeDistance = track.width / 2 - 15;
              
              car.x = closestPoint.x + normalX * safeDistance;
              car.y = closestPoint.y + normalY * safeDistance;
              car.velocity.x *= 0.3; // Severe speed penalty for extreme off-track
              car.velocity.y *= 0.3;
            } else {
              repositionCarOnTrack(car, closestPoint);
            }
          }
        }
      }

      /**
       * Track Rendering System
       *
       * Renders the racing circuit with multiple visual layers and surface types.
       * Uses optimized viewport culling to only draw visible portions of the large track.
       *
       * Rendering Layers (back to front):
       * 1. Grass background with gradient texture
       * 2. Track surface (asphalt with texture patterns)
       * 3. Track centerline (racing line guide)
       * 4. Kerbs at track edges (red/white striped barriers)
       * 5. Checkpoint markers (visual lap validation points)
       * 6. Start/finish line with grid pattern
       *
       * Performance Features:
       * - Viewport culling (only renders visible track sections)
       * - Gradient backgrounds for depth perception
       * - Texture patterns for surface variety
       */
      function drawTrack() {
        // Clear with gradient grass background - draw in world coordinates
        // Calculate world bounds that are visible on screen
        const worldLeft = camera.x;
        const worldTop = camera.y;
        const worldRight = camera.x + canvas.width;
        const worldBottom = camera.y + canvas.height;

        // Add padding to ensure no gaps
        const padding = 200;
        
        // Weather-based grass colors
        let grassColors;
        if (gameWeather === 'clear') {
          grassColors = {
            start: "#3a7c3a",
            middle: "#2d5a2d", 
            end: "#1f4a1f"
          };
        } else if (gameWeather === 'rain') {
          grassColors = {
            start: "#2a5c2a",
            middle: "#1d3a1d",
            end: "#0f2a0f"
          };
        } else if (gameWeather === 'storm') {
          grassColors = {
            start: "#1a3c1a",
            middle: "#0d2a0d",
            end: "#051a05"
          };
        }
        
        const grassGradient = ctx.createLinearGradient(
          worldLeft - padding,
          worldTop - padding,
          worldRight + padding,
          worldBottom + padding
        );
        grassGradient.addColorStop(0, grassColors.start);
        grassGradient.addColorStop(0.5, grassColors.middle);
        grassGradient.addColorStop(1, grassColors.end);

        ctx.fillStyle = grassGradient;
        ctx.fillRect(
          worldLeft - padding,
          worldTop - padding,
          canvas.width + padding * 2,
          canvas.height + padding * 2
        );

        // Draw track shadow/depth
        ctx.strokeStyle = "#202020";
        ctx.lineWidth = track.width + 8;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();

        track.waypoints.forEach((point, index) => {
          if (index === 0) {
            ctx.moveTo(point.x + 2, point.y + 2);
          } else {
            ctx.lineTo(point.x + 2, point.y + 2);
          }
        });
        ctx.closePath();
        ctx.stroke();

        // Draw track outline (kerbs) with red/white stripes
        ctx.lineWidth = track.width;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        // Create kerb pattern
        const kerbGradient = ctx.createLinearGradient(0, 0, 50, 50);
        kerbGradient.addColorStop(0, "#ff0000");
        kerbGradient.addColorStop(0.5, "#ffffff");
        kerbGradient.addColorStop(1, "#ff0000");

        ctx.strokeStyle = kerbGradient;
        ctx.beginPath();

        track.waypoints.forEach((point, index) => {
          if (index === 0) {
            ctx.moveTo(point.x, point.y);
          } else {
            ctx.lineTo(point.x, point.y);
          }
        });
        ctx.closePath();
        ctx.stroke();

        // Draw track surface (asphalt) with texture
        ctx.lineWidth = track.width - 20;
        ctx.beginPath();

        track.waypoints.forEach((point, index) => {
          if (index === 0) {
            ctx.moveTo(point.x, point.y);
          } else {
            ctx.lineTo(point.x, point.y);
          }
        });
        ctx.closePath();

        // Base asphalt
        const asphaltGradient = ctx.createLinearGradient(
          0,
          0,
          canvas.width,
          canvas.height
        );
        asphaltGradient.addColorStop(0, "#4a4a4a");
        asphaltGradient.addColorStop(0.3, "#555555");
        asphaltGradient.addColorStop(0.7, "#3a3a3a");
        asphaltGradient.addColorStop(1, "#454545");

        ctx.strokeStyle = asphaltGradient;
        ctx.stroke();

        // Add asphalt texture overlay
        ctx.save();
        ctx.clip();
        ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
        for (let i = 0; i < 500; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          ctx.fillRect(x, y, 1, 1);
        }
        ctx.restore();

        // Draw center line with better styling
        ctx.strokeStyle = "#ffff00";
        ctx.lineWidth = 3;
        ctx.setLineDash([30, 20]);
        ctx.beginPath();

        track.waypoints.forEach((point, index) => {
          if (index === 0) {
            ctx.moveTo(point.x, point.y);
          } else {
            ctx.lineTo(point.x, point.y);
          }
        });
        ctx.closePath();
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw enhanced start/finish line
        const startPoint = track.waypoints[0];

        // Just draw a wide white line for start/finish
        ctx.fillStyle = "#ffffff";
        ctx.save();
        ctx.translate(startPoint.x, startPoint.y);

        // Calculate perpendicular direction for the line
        const nextPoint = track.waypoints[1];
        const dx = nextPoint.x - startPoint.x;
        const dy = nextPoint.y - startPoint.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const perpX = -dy / length;
        const perpY = dx / length;

        // Draw start/finish line across track width
        const lineWidth = track.width - 10;
        ctx.fillRect(
          (-lineWidth / 2) * perpX - 2,
          (-lineWidth / 2) * perpY - 2,
          4,
          lineWidth + 4
        );
        ctx.rotate(Math.atan2(perpY, perpX));
        ctx.fillRect(-lineWidth / 2, -2, lineWidth, 4);
        ctx.restore();

        // Draw checkpoint gates with better styling using checkpoint array
        track.checkpoints.forEach((checkpoint, index) => {
          const point = checkpoint;

          // Special handling for finish line (checkpoint 0) - make it wider
          if (index === 0) {
            // Wide finish line spanning optimal racing area
            const finishWidth = 240;
            const finishHeight = 80;
            const centerX = point.x;
            const centerY = point.y;

            // Draw wider finish line area with checkerboard pattern
            ctx.save();

            // Background rectangle
            ctx.fillStyle = "#000000";
            ctx.fillRect(
              centerX - finishWidth / 2,
              centerY - finishHeight / 2,
              finishWidth,
              finishHeight
            );

            // Checkerboard pattern for finish line
            const squareSize = 20;
            for (let x = 0; x < finishWidth; x += squareSize) {
              for (let y = 0; y < finishHeight; y += squareSize) {
                const isWhite = (x / squareSize + y / squareSize) % 2 === 0;
                ctx.fillStyle = isWhite ? "#ffffff" : "#000000";
                ctx.fillRect(
                  centerX - finishWidth / 2 + x,
                  centerY - finishHeight / 2 + y,
                  squareSize,
                  squareSize
                );
              }
            }

            // Border for finish line
            ctx.strokeStyle = "#ff0000";
            ctx.lineWidth = 3;
            ctx.strokeRect(
              centerX - finishWidth / 2,
              centerY - finishHeight / 2,
              finishWidth,
              finishHeight
            );

            // Finish line text
            ctx.fillStyle = "#ff0000";
            ctx.font = "bold 16px Arial";
            ctx.textAlign = "center";
            ctx.fillText(
              "START/FINISH",
              centerX,
              centerY - finishHeight / 2 - 10
            );

            ctx.restore();
          } else {
            // Regular checkpoint gate for other checkpoints
            // Find nearby waypoints to calculate gate direction
            let closestWaypointIndex = 0;
            let minDistance = Infinity;

            track.waypoints.forEach((waypoint, wpIndex) => {
              const distance = Math.sqrt(
                (waypoint.x - point.x) * (waypoint.x - point.x) +
                  (waypoint.y - point.y) * (waypoint.y - point.y)
              );
              if (distance < minDistance) {
                minDistance = distance;
                closestWaypointIndex = wpIndex;
              }
            });

            // Calculate gate direction perpendicular to track
            const prevPoint =
              track.waypoints[
                closestWaypointIndex > 0
                  ? closestWaypointIndex - 1
                  : track.waypoints.length - 1
              ];
            const nextPoint =
              track.waypoints[
                (closestWaypointIndex + 1) % track.waypoints.length
              ];

            const dx = nextPoint.x - prevPoint.x;
            const dy = nextPoint.y - prevPoint.y;
            const length = Math.sqrt(dx * dx + dy * dy);

            if (length > 0) {
              // Perpendicular vector for gate orientation
              const perpX = -dy / length;
              const perpY = dx / length;

              // Gate spans the full width of the track
              const gateWidth = track.width - 10; // Slightly smaller than track width
              const post1X = point.x + (perpX * gateWidth) / 2;
              const post1Y = point.y + (perpY * gateWidth) / 2;
              const post2X = point.x - (perpX * gateWidth) / 2;
              const post2Y = point.y - (perpY * gateWidth) / 2;

              // Post shadows
              ctx.fillStyle = "#800000";
              ctx.beginPath();
              ctx.arc(post1X + 2, post1Y + 2, 12, 0, 2 * Math.PI);
              ctx.fill();
              ctx.beginPath();
              ctx.arc(post2X + 2, post2Y + 2, 12, 0, 2 * Math.PI);
              ctx.fill();

              // Gate posts with gradient
              const postGradient = ctx.createRadialGradient(
                post1X,
                post1Y,
                0,
                post1X,
                post1Y,
                12
              );
              postGradient.addColorStop(0, "#ff6666");
              postGradient.addColorStop(1, "#cc0000");

              ctx.fillStyle = postGradient;
              ctx.beginPath();
              ctx.arc(post1X, post1Y, 10, 0, 2 * Math.PI);
              ctx.fill();

              ctx.beginPath();
              ctx.arc(post2X, post2Y, 10, 0, 2 * Math.PI);
              ctx.fill();

              // Gate line with glow effect - spans full track width
              ctx.shadowColor = "#ff4444";
              ctx.shadowBlur = 10;
              ctx.strokeStyle = "#ff4444";
              ctx.lineWidth = 4;
              ctx.setLineDash([15, 10]);
              ctx.beginPath();
              ctx.moveTo(post1X, post1Y);
              ctx.lineTo(post2X, post2Y);
              ctx.stroke();
              ctx.setLineDash([]);
              ctx.shadowBlur = 0;

              // Enhanced checkpoint number display
              ctx.save();

              // Background circle for number
              ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
              ctx.beginPath();
              ctx.arc(point.x, point.y - 25, 18, 0, 2 * Math.PI);
              ctx.fill();

              // White border for circle
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(point.x, point.y - 25, 18, 0, 2 * Math.PI);
              ctx.stroke();

              // Gate number with better styling
              ctx.fillStyle = "#ffffff";
              ctx.font = "bold 20px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(`${checkpoint.id}`, point.x, point.y - 25);

              // Checkpoint name below
              ctx.fillStyle = "#ffff00";
              ctx.font = "bold 12px Arial";
              ctx.strokeStyle = "#000000";
              ctx.lineWidth = 3;
              ctx.strokeText(checkpoint.name, point.x, point.y + 25);
              ctx.fillText(checkpoint.name, point.x, point.y + 25);

              ctx.restore();
            }
          }
        });
      }

      /**
       * Formula 1 Style Car Rendering System
       * Draws detailed race cars with multiple visual components and effects.
       * Uses modular approach to separate chassis, cockpit, wings, and details.
       */
      function drawCar(car) {
        ctx.save();

        // Position and orient the car in world space
        ctx.translate(car.x, car.y);
        ctx.rotate(car.angle);

        // Calculate scaling and dimensions for this car
        const dimensions = {
          width: car.size,
          height: car.size * 0.5,
          scale: car.size / 20,
        };

        // Setup rendering context (shadows, transparency effects)
        setupCarRendering(car, dimensions);

        // Render car components in back-to-front order
        drawCarChassis(car, dimensions); // Main body structure
        drawCarCockpit(dimensions); // Driver area
        drawCarNose(car, dimensions); // Front aerodynamics
        drawCarWings(car, dimensions); // Front and rear wings
        drawCarWheels(dimensions); // All four wheels
        drawCarDetails(car, dimensions); // Numbers, team codes, indicators
        drawCarEffects(car, dimensions); // Speed trails, damage, nitro effects

        ctx.restore();
      }

      function setupCarRendering(car, dimensions) {
        const raceTime = gameRunning ? (Date.now() - raceStartTime) / 1000 : 0;
        const isGhosted =
          car.lapsCompleted === 0 &&
          car.currentCheckpoint <= 2 &&
          raceTime <= 15;

        if (isGhosted) {
          ctx.globalAlpha = 0.7;
        }

        // Car shadow
        ctx.shadowColor = "rgba(0, 0, 0, 0.4)";
        ctx.shadowBlur = 4 * dimensions.scale;
        ctx.shadowOffsetX = 2 * dimensions.scale;
        ctx.shadowOffsetY = 2 * dimensions.scale;
      }

      function drawCarChassis(car, dimensions) {
        const { width, height, scale } = dimensions;

        const chassisGradient = ctx.createLinearGradient(
          -width / 2,
          -height / 2,
          width / 2,
          height / 2
        );
        chassisGradient.addColorStop(0, lightenColor(car.color, 20));
        chassisGradient.addColorStop(0.3, car.color);
        chassisGradient.addColorStop(0.7, shadeColor(car.color, -20));
        chassisGradient.addColorStop(1, shadeColor(car.color, -40));

        ctx.fillStyle = chassisGradient;
        ctx.beginPath();
        ctx.moveTo(width / 2 - 2 * scale, 0);
        ctx.quadraticCurveTo(width / 3, -height / 3, width / 6, -height / 2);
        ctx.lineTo(-width / 3, -height / 2);
        ctx.quadraticCurveTo(-width / 2, -height / 3, -width / 2, 0);
        ctx.quadraticCurveTo(-width / 2, height / 3, -width / 3, height / 2);
        ctx.lineTo(width / 6, height / 2);
        ctx.quadraticCurveTo(width / 3, height / 3, width / 2 - 2 * scale, 0);
        ctx.closePath();
        ctx.fill();

        // Reset shadow for other elements
        ctx.shadowColor = "transparent";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }

      function drawCarCockpit(dimensions) {
        const { width, height, scale } = dimensions;

        const cockpitGradient = ctx.createRadialGradient(
          0,
          0,
          0,
          0,
          0,
          width / 4
        );
        cockpitGradient.addColorStop(0, "rgba(20, 20, 20, 0.9)");
        cockpitGradient.addColorStop(1, "rgba(0, 0, 0, 1)");

        ctx.fillStyle = cockpitGradient;
        ctx.beginPath();
        ctx.ellipse(-width / 8, 0, width / 4, height / 3, 0, 0, 2 * Math.PI);
        ctx.fill();

        // Driver helmet
        ctx.fillStyle = "#1E90FF";
        ctx.beginPath();
        ctx.arc(-width / 8, 0, 3 * scale, 0, 2 * Math.PI);
        ctx.fill();

        // Helmet visor reflection
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.beginPath();
        ctx.arc(-width / 8 - scale, -scale, 1.5 * scale, 0, Math.PI);
        ctx.fill();
      }

      function drawCarNose(car, dimensions) {
        const { width, scale } = dimensions;

        const noseGradient = ctx.createLinearGradient(
          width / 4,
          0,
          width / 2,
          0
        );
        noseGradient.addColorStop(0, car.color);
        noseGradient.addColorStop(1, lightenColor(car.color, 10));

        ctx.fillStyle = noseGradient;
        ctx.beginPath();
        ctx.moveTo(width / 2 - 2 * scale, 0);
        ctx.lineTo(width / 2 + 4 * scale, -2 * scale);
        ctx.lineTo(width / 2 + 6 * scale, 0);
        ctx.lineTo(width / 2 + 4 * scale, 2 * scale);
        ctx.closePath();
        ctx.fill();
      }

      function drawCarWings(car, dimensions) {
        const { width, height, scale } = dimensions;

        // Front wing elements
        ctx.fillStyle = shadeColor(car.color, -30);
        ctx.strokeStyle = "#333333";
        ctx.lineWidth = 0.5;

        ctx.fillRect(width / 3, -height / 2 - 3 * scale, width / 4, 2 * scale);
        ctx.strokeRect(
          width / 3,
          -height / 2 - 3 * scale,
          width / 4,
          2 * scale
        );
        ctx.fillRect(width / 3, height / 2 + scale, width / 4, 2 * scale);
        ctx.strokeRect(width / 3, height / 2 + scale, width / 4, 2 * scale);

        // Side radiator intakes
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(-width / 8, -height / 2 + 2 * scale, width / 8, 3 * scale);
        ctx.fillRect(-width / 8, height / 2 - 5 * scale, width / 8, 3 * scale);

        // Rear wing
        ctx.fillStyle = shadeColor(car.color, -25);
        ctx.fillRect(
          -width / 2 - 4 * scale,
          -height / 2.5,
          3 * scale,
          height / 1.25
        );

        // Wing endplates
        ctx.fillStyle = "#333333";
        ctx.fillRect(
          -width / 2 - 4 * scale,
          -height / 2.5,
          scale,
          height / 1.25
        );
        ctx.fillRect(
          -width / 2 - 2 * scale,
          -height / 2.5,
          scale,
          height / 1.25
        );
      }

      function drawCarWheels(dimensions) {
        const { width, height, scale } = dimensions;

        drawWheel(
          width / 3,
          -height / 2 - 2 * scale,
          4 * scale,
          2 * scale,
          true
        );
        drawWheel(
          width / 3,
          height / 2 + 2 * scale,
          4 * scale,
          2 * scale,
          true
        );
        drawWheel(
          -width / 3,
          -height / 2 - 2 * scale,
          5 * scale,
          3 * scale,
          false
        );
        drawWheel(
          -width / 3,
          height / 2 + 2 * scale,
          5 * scale,
          3 * scale,
          false
        );
      }

      function drawCarDetails(car, dimensions) {
        const { width, height, scale } = dimensions;

        drawCarNumber(car, width, scale);
        drawTeamCode(car, width, height, scale);
        drawBehaviorIndicator(car);
      }

      function drawCarNumber(car, width, scale) {
        if (car === player) {
          ctx.fillStyle = "#FFFFFF";
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 1;
          ctx.font = `bold ${8 * scale}px Arial`;
          ctx.textAlign = "center";
          ctx.strokeText("1", width / 4, 2 * scale);
          ctx.fillText("1", width / 4, 2 * scale);
        } else if (car.name) {
          const carNumber = aiCars.indexOf(car) + 2;
          ctx.fillStyle = "#FFFFFF";
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 0.5;
          ctx.font = `bold ${6 * scale}px Arial`;
          ctx.textAlign = "center";
          ctx.strokeText(carNumber.toString(), width / 4, 2 * scale);
          ctx.fillText(carNumber.toString(), width / 4, 2 * scale);
        }
      }

      function drawTeamCode(car, width, height, scale) {
        if (car.teamAttributes || car.name) {
          const teamCode = getTeamCode(car);
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.font = `bold ${4 * scale}px Arial`;
          ctx.textAlign = "center";
          ctx.fillText(teamCode, -width / 6, -height / 4);
        }
      }

      function drawBehaviorIndicator(car) {
        if (!car.behavior) return;

        ctx.restore();
        ctx.save();
        ctx.translate(car.x, car.y);

        const colors = {
          overtaking: "rgba(255, 255, 0, 0.6)",
          defending: "rgba(255, 0, 0, 0.6)",
          avoiding: "rgba(255, 165, 0, 0.6)",
        };

        const color = colors[car.behavior.state];
        if (color) {
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(0, -15, 3, 0, 2 * Math.PI);
          ctx.fill();
        }

        ctx.restore();
        ctx.save();
        ctx.translate(car.x, car.y);
        ctx.rotate(car.angle);
      }

      function drawCarEffects(car, dimensions) {
        const { width, height, scale } = dimensions;

        drawSpeedEffects(car, width, scale);
        drawStunnedEffect(car, width, height);
        drawDamageEffects(car, width, height);
      }

      function drawSpeedEffects(car, width, scale) {
        if (car.speed <= 3) return;

        const speedAlpha = Math.min(0.8, car.speed / 8);
        ctx.strokeStyle = `rgba(255, 255, 255, ${speedAlpha})`;
        ctx.lineWidth = 1.5 * scale;

        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(-width / 2 - (6 + i * 2) * scale, (i - 1) * 2 * scale);
          ctx.lineTo(-width / 2 - (10 + i * 3) * scale, (i - 1) * 2 * scale);
          ctx.stroke();
        }
      }

      function drawStunnedEffect(car, width, height) {
        if (!car.stunned || car.stunned <= 0) return;

        ctx.strokeStyle = "rgba(255, 255, 0, 0.8)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const x = Math.cos(angle) * (width / 2 + 8);
          const y = Math.sin(angle) * (height / 2 + 8);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }

      function drawDamageEffects(car, width, height) {
        if (!car.damage || !car.damage.visible) return;

        const totalDamage =
          car.damage.speed +
          car.damage.acceleration +
          car.damage.handling +
          car.damage.braking;

        drawSmokeEffect(totalDamage, width);
        drawSparksEffect(totalDamage, width, height);
        drawDamageOverlay(totalDamage, width, height);
      }

      function drawSmokeEffect(totalDamage, width) {
        if (totalDamage <= 20) return;

        ctx.fillStyle = `rgba(80, 80, 80, ${Math.min(0.6, totalDamage / 200)})`;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.arc(
            -width / 2 - 5 + i * 2,
            Math.sin(Date.now() * 0.01 + i) * 3,
            2 + Math.random() * 2,
            0,
            2 * Math.PI
          );
          ctx.fill();
        }
      }

      function drawSparksEffect(totalDamage, width, height) {
        if (totalDamage <= 50 || Math.random() >= 0.1) return;

        ctx.fillStyle = `rgba(255, 200, 0, 0.8)`;
        for (let i = 0; i < 2; i++) {
          ctx.beginPath();
          ctx.arc(
            (Math.random() - 0.5) * width,
            (Math.random() - 0.5) * height,
            1,
            0,
            2 * Math.PI
          );
          ctx.fill();
        }
      }

      function drawDamageOverlay(totalDamage, width, height) {
        if (totalDamage <= 30) return;

        ctx.fillStyle = `rgba(255, 0, 0, ${Math.min(0.3, totalDamage / 400)})`;
        ctx.beginPath();
        ctx.ellipse(0, 0, width / 2, height / 2, 0, 0, 2 * Math.PI);
        ctx.fill();
      }

      function drawWheel(x, y, width, height, isFront) {
        ctx.save();
        ctx.translate(x, y);

        // Wheel shadow
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.beginPath();
        ctx.ellipse(1, 1, width / 2 + 1, height / 2 + 1, 0, 0, 2 * Math.PI);
        ctx.fill();

        // Main tire
        ctx.fillStyle = "#1a1a1a";
        ctx.beginPath();
        ctx.ellipse(0, 0, width / 2, height / 2, 0, 0, 2 * Math.PI);
        ctx.fill();

        // Tire sidewall
        ctx.strokeStyle = "#333333";
        ctx.lineWidth = 1;
        ctx.stroke();

        // Rim
        const rimGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, width / 3);
        rimGradient.addColorStop(0, "#888888");
        rimGradient.addColorStop(0.7, "#444444");
        rimGradient.addColorStop(1, "#222222");

        ctx.fillStyle = rimGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, width / 3, height / 3, 0, 0, 2 * Math.PI);
        ctx.fill();

        // Spokes
        ctx.strokeStyle = "#666666";
        ctx.lineWidth = 0.5;
        for (let i = 0; i < 5; i++) {
          const angle = (i / 5) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(
            (Math.cos(angle) * width) / 3,
            (Math.sin(angle) * height) / 3
          );
          ctx.stroke();
        }

        // Brake disc
        if (isFront) {
          ctx.fillStyle = "#666666";
          ctx.beginPath();
          ctx.ellipse(0, 0, width / 4, height / 4, 0, 0, 2 * Math.PI);
          ctx.fill();
        }

        ctx.restore();
      }

      // Helper function to shade colors
      // Lighten a color by a given percentage
      function lightenColor(color, percent) {
        const f = parseInt(color.slice(1), 16);
        const R = f >> 16;
        const G = (f >> 8) & 0x00ff;
        const B = f & 0x0000ff;
        return (
          "#" +
          (
            0x1000000 +
            Math.min(255, Math.round(R + (255 - R) * (percent / 100))) *
              0x10000 +
            Math.min(255, Math.round(G + (255 - G) * (percent / 100))) * 0x100 +
            Math.min(255, Math.round(B + (255 - B) * (percent / 100)))
          )
            .toString(16)
            .slice(1)
        );
      }

      function shadeColor(color, percent) {
        const f = parseInt(color.slice(1), 16);
        const t = percent < 0 ? 0 : 255;
        const p = percent < 0 ? percent * -1 : percent;
        const R = f >> 16;
        const G = (f >> 8) & 0x00ff;
        const B = f & 0x0000ff;
        return (
          "#" +
          (
            0x1000000 +
            (Math.round(((t - R) * p) / 100) + R) * 0x10000 +
            (Math.round(((t - G) * p) / 100) + G) * 0x100 +
            (Math.round(((t - B) * p) / 100) + B)
          )
            .toString(16)
            .slice(1)
        );
      }

      // Get team code/initials for displaying on cars
      function getTeamCode(car) {
        // For player car, use the selected team
        if (car === player || car.isPlayer) {
          if (typeof selectedTeam === "string") {
            const teamIdMap = {
              emerald_isle: "EIR",
              dragon_force: "DFM",
              highland_racing: "HRT",
              britannia_motors: "BRT",
              tricolore_racing: "TCR",
              kaiser_motorsport: "KMS",
              iberian_speed: "IBS",
              veloce_italia: "VIT",
              adriatic_racing: "ADR",
              liberty_racing: "LBR",
              rising_sun: "RSM",
              celestial_motors: "CEL",
              maharaja_motors: "MHJ",
              samba_racing: "SRT",
              velocidad_venezuela: "VEV",
              regina_curse: "RGC",
            };
            return teamIdMap[selectedTeam] || "PLR";
          }
          return "PLR";
        }

        // If AI car has a name property, extract code from it
        if (car.name) {
          // Map team names to their 3-letter codes
          const teamCodeMap = {
            "Emerald Isle Racing": "EIR",
            "Dragon Force Motorsport": "DFM",
            "Highland Racing Team": "HRT",
            "Britannia Motors": "BRT",
            "Tricolore Racing": "TCR",
            "Kaiser Motorsport": "KMS",
            "Iberian Speed": "IBS",
            "Veloce Italia": "VIT",
            "Adriatic Racing": "ADR",
            "Liberty Racing": "LBR",
            "Rising Sun Motors": "RSM",
            "Celestial Motors": "CEL",
            "Maharaja Motors": "MHJ",
            "Samba Racing Team": "SRT",
            "Velocidad Venezuela": "VEV",
            "Regina Curse": "RGC",
          };

          return teamCodeMap[car.name] || "AI";
        }

        // Default for unknown cars
        return "AI";
      }

      // Draw tire marks
      function drawTireMarks() {
        tireMarks.forEach((mark, index) => {
          mark.age++;
          mark.alpha -= 0.005;

          if (mark.alpha <= 0) {
            tireMarks.splice(index, 1);
            return;
          }

          ctx.save();
          ctx.globalAlpha = mark.alpha;
          ctx.translate(mark.x, mark.y);
          ctx.rotate(mark.angle);
          ctx.fillStyle = "#2a2a2a";
          ctx.fillRect(-8, -1, 16, 2);
          ctx.fillRect(-8, -4, 16, 2);
          ctx.restore();
        });
      }

      // Draw sparkles
      function drawSparkles() {
        sparkles.forEach((sparkle, index) => {
          sparkle.life--;
          sparkle.x += sparkle.vx;
          sparkle.y += sparkle.vy;
          sparkle.vx *= 0.98;
          sparkle.vy *= 0.98;

          if (sparkle.life <= 0) {
            sparkles.splice(index, 1);
            return;
          }

          ctx.save();
          ctx.globalAlpha = sparkle.life / sparkle.maxLife;
          ctx.fillStyle = "#ffff00";
          ctx.beginPath();
          ctx.arc(sparkle.x, sparkle.y, 2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.restore();
        });
      }

      // Draw flame effects
      function drawFlames() {
        flames.forEach((flame, index) => {
          flame.life--;
          flame.x += flame.vx;
          flame.y += flame.vy;
          flame.vx *= 0.95;
          flame.vy *= 0.95;
          flame.size *= 0.98;

          if (flame.life <= 0 || flame.size < 0.5) {
            flames.splice(index, 1);
            return;
          }

          const alpha = flame.life / flame.maxLife;
          ctx.save();
          ctx.globalAlpha = alpha;

          // Create flame gradient from yellow to red to transparent
          const flameGradient = ctx.createRadialGradient(
            flame.x,
            flame.y,
            0,
            flame.x,
            flame.y,
            flame.size
          );
          if (alpha > 0.7) {
            flameGradient.addColorStop(0, "#ffffff");
            flameGradient.addColorStop(0.3, "#ffff00");
            flameGradient.addColorStop(0.7, "#ff6600");
            flameGradient.addColorStop(1, "#ff0000");
          } else if (alpha > 0.4) {
            flameGradient.addColorStop(0, "#ffff00");
            flameGradient.addColorStop(0.5, "#ff6600");
            flameGradient.addColorStop(1, "#ff0000");
          } else {
            flameGradient.addColorStop(0, "#ff6600");
            flameGradient.addColorStop(1, "#440000");
          }

          ctx.fillStyle = flameGradient;
          ctx.beginPath();
          ctx.arc(flame.x, flame.y, flame.size, 0, 2 * Math.PI);
          ctx.fill();
          ctx.restore();
        });
      }

      // Update UI
      function updateUI() {
        const speedValue = Math.round(player.speed * 20);

        // Use player position from finalRaceStandings if race is complete
        const playerPosition = raceComplete ? player.racePosition : player.racePosition;

        // Update existing UI
        document.getElementById("speed").textContent = speedValue + " km/h";
        document.getElementById(
          "lap"
        ).textContent = `${currentLap}/${totalLaps}`;
        document.getElementById("position").textContent = `${
          playerPosition
        }/${aiCars.length + 1}`;

        // Update broadcast bar
        document.getElementById("speedDisplay").textContent =
          speedValue + " KM/H";
        document.getElementById(
          "currentLapDisplay"
        ).textContent = `${currentLap}/${totalLaps}`;
        document.getElementById(
          "positionDisplay"
        ).textContent = `P${playerPosition}`;

        // Update nitro bar
        const nitroPercentage = (player.nitro / player.maxNitro) * 100;
        document.getElementById("nitroBar").style.width = `${nitroPercentage}%`;

        // Change nitro bar color based on level using theme colors
        if (nitroPercentage > 50) {
          document.getElementById(
            "nitroBar"
          ).style.background = `linear-gradient(90deg, var(--primary-color), var(--accent-color))`;
        } else if (nitroPercentage > 20) {
          document.getElementById(
            "nitroBar"
          ).style.background = `linear-gradient(90deg, var(--accent-color), #ffaa00)`;
        } else {
          document.getElementById("nitroBar").style.background = "#ff3333";
        }

        // Update tire wear bar (reverse - starts full, decreases as tires wear)
        const tireCondition = Math.max(0, 100 - player.tireWear);
        document.getElementById("tireBar").style.width = `${tireCondition}%`;

        // Update lap time displays
        if (gameRunning) {
          // Current lap time
          const currentTime = Date.now();
          if (lapStartTime > 0) {
            currentLapTime = (currentTime - lapStartTime) / 1000;
            const lapMinutes = Math.floor(currentLapTime / 60);
            const lapSeconds = (currentLapTime % 60).toFixed(3);
            document.getElementById(
              "currentLapTimeDisplay"
            ).textContent = `${lapMinutes}:${lapSeconds.padStart(6, "0")}`;
          }

          // Best lap time for current race
          if (bestLapTime < Number.MAX_VALUE) {
            const bestLapMinutes = Math.floor(bestLapTime / 60);
            const bestLapSeconds = (bestLapTime % 60).toFixed(3);
            document.getElementById(
              "bestLapTimeDisplay"
            ).textContent = `${bestLapMinutes}:${bestLapSeconds.padStart(
              6,
              "0"
            )}`;
          } else {
            document.getElementById("bestLapTimeDisplay").textContent = "-:--:---";
          }
          
          // All-time lap record
          if (lapRecord < Number.MAX_VALUE) {
            const recordMinutes = Math.floor(lapRecord / 60);
            const recordSeconds = (lapRecord % 60).toFixed(3);
            document.getElementById(
              "lapRecordDisplay"
            ).textContent = `${recordMinutes}:${recordSeconds.padStart(
              6,
              "0"
            )}`;
          } else {
            document.getElementById("lapRecordDisplay").textContent = "-:--:---";
          }

          // Race time
          const raceElapsed = (currentTime - raceStartTime) / 1000;
          const raceMinutes = Math.floor(raceElapsed / 60);
          const raceSeconds = (raceElapsed % 60).toFixed(1);
          document.getElementById(
            "raceTimeDisplay"
          ).textContent = `${raceMinutes}:${raceSeconds.padStart(4, "0")}`;
        }

        // Update damage bar
        const totalDamage =
          player.damage.speed +
          player.damage.acceleration +
          player.damage.handling +
          player.damage.braking;
        const damagePercentage = Math.min(100, (totalDamage / 200) * 100); // Max damage shown at 200 total points
        document.getElementById(
          "damageBar"
        ).style.width = `${damagePercentage}%`;

        if (gameRunning) {
          const elapsed = (Date.now() - raceStartTime) / 1000;
          const minutes = Math.floor(elapsed / 60);
          const seconds = Math.floor(elapsed % 60);
          const milliseconds = Math.floor((elapsed % 1) * 1000);

          // Update existing timer with thousandths precision
          document.getElementById("time").textContent = `${minutes}:${seconds
            .toString()
            .padStart(2, "0")}.${milliseconds.toString().padStart(3, "0")}`;

          // Update broadcast timer with thousandths precision
          document.getElementById(
            "raceTimeDisplay"
          ).textContent = `${minutes}:${seconds
            .toString()
            .padStart(2, "0")}.${milliseconds.toString().padStart(3, "0")}`;

          // Check if ghosting is active for the player
          const minCheckpointsForCollisions = 2;
          const maxGhostingTime = 15;
          const playerGhosted =
            player.lapsCompleted === 0 &&
            player.currentCheckpoint <= minCheckpointsForCollisions &&
            elapsed <= maxGhostingTime;

          // Update ghosting indicator
          const ghostingIndicator =
            document.getElementById("ghostingIndicator");
          if (playerGhosted) {
            if (!ghostingIndicator) {
              // Create ghosting indicator if it doesn't exist
              const indicator = document.createElement("div");
              indicator.id = "ghostingIndicator";
              indicator.style.cssText = `
                            position: absolute;
                            top: 120px;
                            left: 20px;
                            background: rgba(0, 123, 255, 0.9);
                            color: white;
                            padding: 8px 12px;
                            border-radius: 4px;
                            font-family: 'Orbitron', monospace;
                            font-size: 14px;
                            font-weight: bold;
                            border: 2px solid #0080ff;
                            animation: ghostPulse 2s infinite;
                            z-index: 1000;
                        `;
              indicator.textContent = "🛡️ COLLISION PROTECTION ACTIVE";
              document.body.appendChild(indicator);

              // Add CSS animation if not already added
              if (!document.getElementById("ghostingAnimation")) {
                const style = document.createElement("style");
                style.id = "ghostingAnimation";
                style.textContent = `
                                @keyframes ghostPulse {
                                    0%, 100% { opacity: 1; transform: scale(1); }
                                    50% { opacity: 0.7; transform: scale(1.05); }
                                }
                            `;
                document.head.appendChild(style);
              }
            }
          } else if (ghostingIndicator) {
            // Remove ghosting indicator when no longer active
            ghostingIndicator.remove();
          }
        }
      }

      // Show race complete screen
      function showRaceComplete() {
        // Calculate final race time from player's total lap times
        let finalRaceTime = player.totalRaceTime;
        // Add final lap time if it was in progress
        if (player.currentLapStartTime > 0) {
          const finalLapTime = (Date.now() - player.currentLapStartTime) / 1000;
          finalRaceTime += finalLapTime;
        }

        currentRaceTime = finalRaceTime; // Store for leaderboard
        const minutes = Math.floor(finalRaceTime / 60);
        const seconds = (finalRaceTime % 60).toFixed(3);

        document.getElementById("finalPos").textContent = `${
          player.racePosition
        }/${aiCars.length + 1}`;
        document.getElementById(
          "finalTime"
        ).textContent = `${minutes}:${seconds.padStart(6, "0")}`;

        // Display best lap time
        if (bestLapTime < Number.MAX_VALUE) {
          const bestLapMinutes = Math.floor(bestLapTime / 60);
          const bestLapSeconds = (bestLapTime % 60).toFixed(3);
          document.getElementById(
            "bestLapTime"
          ).textContent = `${bestLapMinutes}:${bestLapSeconds.padStart(
            6,
            "0"
          )}`;
        } else {
          document.getElementById("bestLapTime").textContent = "No valid lap";
        }
        
        // Display lap record
        if (lapRecord < Number.MAX_VALUE) {
          const recordMinutes = Math.floor(lapRecord / 60);
          const recordSeconds = (lapRecord % 60).toFixed(3);
          document.getElementById(
            "lapRecordTime"
          ).textContent = `${recordMinutes}:${recordSeconds.padStart(
            6,
            "0"
          )}`;
        } else {
          document.getElementById("lapRecordTime").textContent = "No record set";
        }

        // Show leaderboard at race end
        updateLeaderboardDisplay();

        // Also update the leaderboard in the race complete dialog
        updateRaceCompleteLeaderboard();

        // Calculate position in leaderboard and splits
        const sortedLeaderboard = [...leaderboard].sort(
          (a, b) => a.time - b.time
        );
        const isNewRecord =
          leaderboard.length < 10 ||
          currentRaceTime < sortedLeaderboard[sortedLeaderboard.length - 1]?.time;
        const recordTime = sortedLeaderboard[0]?.time;

        if (isNewRecord) {
          if (recordTime && currentRaceTime < recordTime) {
            // New fastest time
            document.getElementById("newRecordText").textContent =
              "NEW FASTEST TIME";
            document.getElementById("newRecordText").style.display = "block";
          } else if (leaderboard.length < 10) {
            // Made it to top 10
            document.getElementById("newRecordText").textContent =
              "�️ LEADERBOARD POSITION! �️";
            document.getElementById("newRecordText").style.display = "block";
          } else {
            // Beat previous 10th place
            document.getElementById("newRecordText").textContent =
              "� LEADERBOARD ENTRY! �";
            document.getElementById("newRecordText").style.display = "block";
          }
          document.getElementById("nameInputModal").style.display = "block";
          document.getElementById("raceComplete").style.display = "none";
        } else {
          // Calculate leaderboard position if this time was added
          let position = 1;
          for (const entry of sortedLeaderboard) {
            if (currentRaceTime > entry.time) {
              position++;
            } else {
              break;
            }
          }

          // Calculate split from record
          if (recordTime) {
            const split = currentRaceTime - recordTime;
            const splitMinutes = Math.floor(split / 60);
            const splitSeconds = (split % 60).toFixed(3);
            const splitText =
              splitMinutes > 0
                ? `+${splitMinutes}:${splitSeconds.padStart(6, "0")}`
                : `+${splitSeconds}s`;

            document.getElementById(
              "newRecordText"
            ).textContent = `Leaderboard Position: ${position} | +${splitText} from record`;
          } else {
            document.getElementById(
              "newRecordText"
            ).textContent = `Leaderboard Position: ${position}`;
          }
          document.getElementById("newRecordText").style.color =
            "var(--text-secondary)";
          document.getElementById("newRecordText").style.display = "block";
          document.getElementById("raceComplete").style.display = "block";
        }
      }

      /**
       * Main Game Loop - Core Engine
       * Executes every frame to update game state and render all visual elements.
       * This function coordinates all game systems in the correct order.
       */
      // Store final race standings when race completes
      let finalRaceStandings = [];
      
      function gameLoop() {
        if (gameRunning) {
          // Update player car physics and input handling
          updatePlayer();

          // Update AI cars or ghost cars depending on mode
          if (isTimeTrialMode) {
            updateTimeTrialGhosts();
          } else {
            // Update all AI cars (movement, decision-making, pathfinding)
            updateAI();
            
            // Validate checkpoint progression for lap counting and anti-cheat
            checkAICheckpoints();
            
            // Process collision detection between all cars
            handleCarCollisions();
            
            // Calculate current race positions for all participants
            updatePositions();
            
            // Check if any car has completed the required laps
            checkRaceCompletion();
          }

          // Update camera position to smoothly follow the player
          updateCamera();

          // Update weather effects (rain particles, etc.)
          updateRainParticles();
        }

        // Apply camera transformation matrix for world-space rendering
        applyCameraTransform();

        // Render all world-space objects (affected by camera position)
        drawTrack(); // Track surface and boundaries
        drawTireMarks(); // Persistent tire marks from car movement
        drawFlames(); // Nitro flame effects (drawn behind cars)

        // Render all cars with current positions and rotations
        if (isTimeTrialMode) {
          // Render ghost cars first (behind player)
          timeTrialGhosts.forEach(drawGhostCar);
        } else {
          // Render AI cars in regular race mode
          aiCars.forEach(drawCar);
        }
        drawCar(player);

        // Render collision and interaction effects
        drawSparkles();

        // Render weather effects (rain particles and overlay dimming)
        renderWeatherEffects();

        // Reset camera matrix for UI rendering
        resetCameraTransform();

        // Update all UI elements (not affected by camera movement)
        updateUI();

        // Schedule next frame for smooth 60fps animation
        requestAnimationFrame(gameLoop);
      }

      // Start race
      function startRace() {
        document.getElementById("startScreen").style.display = "none";

        // Show broadcast bar and game UI
        document.querySelector(".broadcast-bar").style.display = "flex";
        document.querySelector(".game-container").classList.add("game-running");

        // Make sure leaderboard is hidden when race starts
        document.querySelector(".leaderboard").style.display = "none";

        gameRunning = true;
        raceStartTime = Date.now();
        currentLap = 1;
        raceComplete = false;
        
        // Clear the final race standings
        finalRaceStandings = [];

        // Reset lap timing
        lapStartTime = 0;
        currentLapTime = 0;
        bestLapTime = Number.MAX_VALUE; // Reset best lap time for this race
        lastLapTime = 0; // Reset last lap time
        lapTimes = [];

        // Reset lap timing and race properties for player
        player.lapTimes = [];
        player.currentLapStartTime = 0;
        player.totalRaceTime = 0;
        player.checkpointTimes = {};
        player.calculatedTotalTime = 0;

        // Reset lap timing and race properties for all AI cars
        aiCars.forEach((car) => {
          car.lapTimes = [];
          car.currentLapStartTime = 0;
          car.totalRaceTime = 0;
          car.checkpointTimes = {};
          car.calculatedTotalTime = 0;
        });

        // Reset UI elements
        document.getElementById("newRecordText").style.color =
          "var(--accent-color)";
        document.getElementById("newRecordText").style.display = "none";
        document.getElementById("nameInputModal").style.display = "none";

        // Reset player to pole position (front of grid)
        player.x = 1000; // Center of track
        player.y = 1300; // Front of the grid (pole position)
        player.angle = -Math.PI / 2; // Point upward initially
        player.velocity = { x: 0, y: 0 };
        player.speed = 0;
        player.currentCheckpoint = 1;
        player.checkpointsHit = [true, false, false];
        player.lapsCompleted = 0;
        player.lapProgress = 0;
        player.racePosition = 1;
        player.nitro = player.maxNitro; // Reset nitro to full
        player.usingNitro = false;

        // Initialize camera to player's starting position
        camera.x = player.x - canvas.width / 2;
        camera.y = player.y - canvas.height / 2;
        camera.targetX = camera.x;
        camera.targetY = camera.y;

        // Reset damage, tire wear for player
        player.damage = {
          speed: 0,
          acceleration: 0,
          handling: 0,
          braking: 0,
          visible: false,
        };
        player.tireWear = 0;
        player.lastCollisionTime = 0;
        player.checkpointTimes = {}; // Reset checkpoint times

        // Reset player stats to base values (team attributes will be reapplied)
        if (player.teamAttributes) {
          // Reapply team effects
          const speedMultiplier =
            0.7 + (player.teamAttributes.speed / 20) * 0.6;
          const accelMultiplier =
            0.7 + (player.teamAttributes.acceleration / 20) * 0.6;
          const handlingMultiplier =
            0.7 + (player.teamAttributes.handling / 20) * 0.6;
          const tireMultiplier =
            0.8 + (player.teamAttributes.tireManagement / 20) * 0.4;
          const reliabilityMultiplier =
            0.8 + (player.teamAttributes.reliability / 20) * 0.4;

          player.maxSpeed = player.baseMaxSpeed * speedMultiplier;
          player.acceleration = player.baseAcceleration * accelMultiplier;
          player.turnSpeed = player.baseTurnSpeed * handlingMultiplier;
          player.friction =
            player.baseFriction + (player.teamAttributes.braking - 10) * 0.002;
          player.tireWearRate = 0.4 / tireMultiplier;
          player.reliabilityFactor = reliabilityMultiplier;
        }

        // Initialize time trial or regular race
        if (isTimeTrialMode) {
          // Time trial mode
          totalLaps = 1; // Single lap for time trial
          
          // Reset ghost cars to start position
          timeTrialGhosts.forEach(ghost => ghost.reset());
          
          // Start recording new ghost data
          currentGhostRecording = [];
          isRecordingGhost = true;
          
          console.log("Time Trial mode started");
        } else {
          // Regular race mode
          totalLaps = 5; // Standard 5-lap race
          
          // Create AI cars
          createAICars();
        }

        // Initialize weather effects for the race
        if (weatherEffects[gameWeather].particles) {
          initializeRainParticles();
        }

        document.getElementById("raceComplete").style.display = "none";
        document.getElementById("timeTrialComplete").style.display = "none";
      }

      // Restart race
      function restartRace() {
        // Reset lap timing variables
        lapStartTime = 0;
        currentLapTime = 0;
        bestLapTime = Number.MAX_VALUE;
        lastLapTime = 0;
        lapTimes = [];

        startRace();
      }

      // Return to team selection
      function returnToTeamSelection() {
        gameRunning = false;

        // Reset lap timing variables
        lapStartTime = 0;
        currentLapTime = 0;
        bestLapTime = Number.MAX_VALUE;
        lastLapTime = 0;
        lapTimes = [];

        // Hide broadcast bar and game UI
        document.querySelector(".broadcast-bar").style.display = "none";
        document
          .querySelector(".game-container")
          .classList.remove("game-running");
        document.querySelector(".leaderboard").style.display = "none";

        document.getElementById("raceComplete").style.display = "none";
        document.getElementById("startScreen").style.display = "none";
        document.getElementById("teamSelectionScreen").style.display = "flex";

        // Reset team selection
        selectedTeam = null;
        document.querySelectorAll(".team-card").forEach((card) => {
          card.classList.remove("selected");
        });
        document.getElementById("proceedToRaceBtn").disabled = true;
      }

      // Clear leaderboard records on game load (optional - remove this line if you want to keep records)
      localStorage.removeItem("circuitRacerLeaderboard");
      leaderboard = [];

      // Initialize and start game loop
      updateLeaderboardDisplay(); // Load leaderboard on page start
      gameLoop();
    </script>
  </body>
</html>